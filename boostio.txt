commit a29291f831ebff938b61d964b27afda5aaaf3cd5
Author: liuwei00960908 <young_liu@fuji.waseda.jp>
Date:   Sun Jan 4 10:36:41 2026 +0800

    Merge branch 'feature_boostio' into main

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 34cd4a0..b4e4c16 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -32,6 +32,27 @@ if(BUILD_TEST)
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DUNIT_TEST")
 endif()
 
+option(FALCON_ENABLE_PLUGINS "Enable plugin support" ON)
+
+if(FALCON_ENABLE_PLUGINS)
+    find_library(DL_LIBRARY dl)
+    if(NOT DL_LIBRARY)
+        message(FATAL_ERROR "dlopen library not found, required for plugin support")
+    endif()
+
+    include(CheckCXXSourceCompiles)
+    check_cxx_source_compiles("
+        #include <filesystem>
+        int main() { std::filesystem::exists(\"/tmp\"); return 0; }
+    " HAS_FILESYSTEM)
+
+    if(NOT HAS_FILESYSTEM)
+        message(FATAL_ERROR "C++17 filesystem support required for plugin system")
+    endif()
+
+    add_definitions(-DFALCON_ENABLE_PLUGINS)
+endif()
+
 # ==================== Dependencies =================
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
 find_package(BRPC REQUIRED)
diff --git a/build.sh b/build.sh
index fd17ab0..8d768cc 100755
--- a/build.sh
+++ b/build.sh
@@ -327,13 +327,19 @@ clean)
     esac
     ;;
 test)
-    TARGET_DIR="$FALCONFS_DIR/build/tests/falcon_store/"
-    # Find executable files directly in the test directory (not in subdirectories)
-    # Exclude .cmake files and anything in CMakeFiles/
-    find "$TARGET_DIR" -maxdepth 1 -type f -executable -not -name "*.cmake" -not -path "*/CMakeFiles/*" | while read -r executable_file; do
-        echo "Executing: $executable_file"
-        "$executable_file"
-        echo "---------------------------------------------------------------------------------------"
+    TARGET_DIRS=("$FALCONFS_DIR/build/tests/falcon_store/" "$FALCONFS_DIR/build/tests/falcon_plugin/")
+
+    for TARGET_DIR in "${TARGET_DIRS[@]}"; do
+        if [ -d "$TARGET_DIR" ]; then
+            echo "Running tests in: $TARGET_DIR"
+            find "$TARGET_DIR" -type f -executable -name "*UT" | while read -r executable_file; do
+                echo "Executing: $executable_file"
+                "$executable_file"
+                echo "---------------------------------------------------------------------------------------"
+            done
+        else
+            echo "Test directory not found: $TARGET_DIR"
+        fi
     done
     echo "All unit tests passed."
     ;;
diff --git a/cloud_native/docker_build/cn/start.sh b/cloud_native/docker_build/cn/start.sh
index 8224504..9a54c02 100644
--- a/cloud_native/docker_build/cn/start.sh
+++ b/cloud_native/docker_build/cn/start.sh
@@ -14,6 +14,8 @@ else
     echo "max_wal_senders=10" >>/home/falconMeta/data/metadata/postgresql.conf
     echo "hot_standby=on" >>/home/falconMeta/data/metadata/postgresql.conf
     echo "synchronous_commit=on" >>/home/falconMeta/data/metadata/postgresql.conf
+    echo "falcon_plugin.directory = '/FalconFS/plugins'" >> /home/falconMeta/data/metadata/postgresql.conf
+    echo "falcon.local_ip = '${NODE_IP:-127.0.0.1}'" >> /home/falconMeta/data/metadata/postgresql.conf
 
     # default replica_server_num set to 2, compatible to ADS.
     replica_server_num=${replica_server_num:-2}
diff --git a/cloud_native/docker_build/dn/start.sh b/cloud_native/docker_build/dn/start.sh
index 12b8920..3f7683a 100644
--- a/cloud_native/docker_build/dn/start.sh
+++ b/cloud_native/docker_build/dn/start.sh
@@ -14,6 +14,9 @@ else
     echo "max_wal_senders=10" >>/home/falconMeta/data/metadata/postgresql.conf
     echo "hot_standby=on" >>/home/falconMeta/data/metadata/postgresql.conf
     echo "synchronous_commit=on" >>/home/falconMeta/data/metadata/postgresql.conf
+    echo "falcon_connection_pool.port = ${NODE_PORT:-5442}" >> /home/falconMeta/data/metadata/postgresql.conf
+    echo "falcon_plugin.directory = '/FalconFS/plugins'" >> /home/falconMeta/data/metadata/postgresql.conf
+    echo "falcon.local_ip = '${NODE_IP:-127.0.0.1}'" >> /home/falconMeta/data/metadata/postgresql.conf
     # default replica_server_num set to 2, compatible to ADS.
     replica_server_num=${replica_server_num:-2}
     sync_replica_num=$(((replica_server_num + 1) / 2))
@@ -29,7 +32,7 @@ else
     echo "log_truncate_on_rotation=on" >>/home/falconMeta/data/metadata/postgresql.conf
     echo "log_rotation_age=1440" >>/home/falconMeta/data/metadata/postgresql.conf
     echo "log_rotation_size=1000000" >>/home/falconMeta/data/metadata/postgresql.conf
-    echo "falcon_connection_pool.port = 5442" >>/home/falconMeta/data/metadata/postgresql.conf
+    
     echo "falcon_connection_pool.pool_size = 64" >>/home/falconMeta/data/metadata/postgresql.conf
     echo "falcon_connection_pool.shmem_size = 256" >>/home/falconMeta/data/metadata/postgresql.conf
     echo "falcon_connection_pool.batch_size = 1024" >>/home/falconMeta/data/metadata/postgresql.conf
diff --git a/cloud_native/falcon_cm/utils/filesystem.py b/cloud_native/falcon_cm/utils/filesystem.py
index 3a640ed..22c4e43 100644
--- a/cloud_native/falcon_cm/utils/filesystem.py
+++ b/cloud_native/falcon_cm/utils/filesystem.py
@@ -54,7 +54,7 @@ def init_filesystem(leader_infos, user, replica_server_num):
     shard_count = 100 * (server_num - 1)
     for i in range(server_num):
         ip, port = split_ip_port(leader_infos[cluster_names[i]])
-        build_shard_map_sql = "SELECT falcon_build_shard_table({});SELECT falcon_create_distributed_data_table();SELECT falcon_start_background_service();".format(
+        build_shard_map_sql = "SELECT falcon_build_shard_table({});SELECT falcon_create_distributed_data_table();SELECT falcon_create_slice_table();SELECT falcon_create_kvmeta_table();SELECT falcon_start_background_service();".format(
             shard_count
         )
         conn = psycopg2.connect(host=ip, port=port, user=user, database="postgres")
diff --git a/deploy/meta/falcon_meta_start.sh b/deploy/meta/falcon_meta_start.sh
index 2d8f321..3b5d737 100755
--- a/deploy/meta/falcon_meta_start.sh
+++ b/deploy/meta/falcon_meta_start.sh
@@ -44,6 +44,8 @@ falcon_connection_pool.batch_size = $FalconConnectionPoolBatchSize
 falcon_connection_pool.wait_adjust = $FalconConnectionPoolWaitAdjust
 falcon_connection_pool.wait_min = $FalconConnectionPoolWaitMin
 falcon_connection_pool.wait_max = $FalconConnectionPoolWaitMax
+falcon_plugin.directory = '$(cd $DIR/../.. && pwd)/plugins'
+falcon.local_ip = '$localIp'
 EOF
         echo "host all all 0.0.0.0/0 trust" >>"$cnPath/pg_hba.conf"
     fi
@@ -90,6 +92,8 @@ falcon_connection_pool.batch_size = $FalconConnectionPoolBatchSize
 falcon_connection_pool.wait_adjust = $FalconConnectionPoolWaitAdjust
 falcon_connection_pool.wait_min = $FalconConnectionPoolWaitMin
 falcon_connection_pool.wait_max = $FalconConnectionPoolWaitMax
+falcon_plugin.directory = '$(cd $DIR/../.. && pwd)/plugins'
+falcon.local_ip = '$localIp'
 EOF
                 echo "host all all 0.0.0.0/0 trust" >>"${workerPath}/pg_hba.conf"
             fi
@@ -149,6 +153,8 @@ if [[ "$cnIp" == "$localIp" ]]; then
 
         psql -d postgres -h "${server_ip_list[i]}" -p "${server_port_list[i]}" <<EOF
 select falcon_create_distributed_data_table();
+select falcon_create_slice_table();
+select falcon_create_kvmeta_table();
 select falcon_start_background_service();
 EOF
     done
diff --git a/docker/build_falcon_docker.sh b/docker/build_falcon_docker.sh
new file mode 100755
index 0000000..1e5bd88
--- /dev/null
+++ b/docker/build_falcon_docker.sh
@@ -0,0 +1,114 @@
+#!/bin/bash
+# 获取脚本所在的目录 (即 ~/code/falconfs/docker)
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+# 切换到脚本的上一级目录 (即项目根目录 ~/code/falconfs)
+PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
+
+echo "正在切换工作目录到项目根目录: $PROJECT_ROOT"
+cd "$PROJECT_ROOT"
+
+# ==============================================================================
+# 配置区域
+# ==============================================================================
+REGISTRY="127.0.0.1:5000"
+# 默认 Git 用户
+DEFAULT_GIT_USER="liuwei00960908"
+# 默认分支
+BRANCH_TAG="main"
+
+GREEN='\033[0;32m'
+RED='\033[0;31m'
+YELLOW='\033[1;33m' 
+NC='\033[0m' # No Color
+
+# ==============================================================================
+# 参数检查
+# ==============================================================================
+if [ "$#" -lt 2 ]; then
+    echo -e "${RED}错误: 参数不足${NC}"
+    echo -e "用法: ./build_falcon_release.sh <镜像版本Tag> <GitCode_Token> [Git用户名]"
+    echo -e "示例: ./build_falcon_release.sh v2.1-release dXJUD1ZjHmizYzNwDgC-VeWu"
+    exit 1
+fi
+
+TARGET_TAG=$1
+GIT_TOKEN=$2
+GIT_USER=${3:-$DEFAULT_GIT_USER}
+
+BASE_IMAGE="${REGISTRY}/falconfs-base-builder:${TARGET_TAG}"
+CN_IMAGE="${REGISTRY}/falconfs-cn:${TARGET_TAG}"
+DN_IMAGE="${REGISTRY}/falconfs-dn:${TARGET_TAG}"
+
+# 遇到错误立即停止
+set -e
+
+echo -e "${GREEN}============================================================${NC}"
+echo -e "${GREEN}开始构建 FalconFS 双架构镜像 (x86 + ARM64)${NC}"
+echo -e "${GREEN}============================================================${NC}"
+echo -e "目标版本: ${YELLOW}${TARGET_TAG}${NC}"
+echo -e "Git 用户: ${YELLOW}${GIT_USER}${NC}"
+echo -e "工作目录: ${YELLOW}$(pwd)${NC}"
+echo ""
+
+# ==============================================================================
+# 0. 检查 Registry
+# ==============================================================================
+if ! docker ps | grep -q "registry"; then
+    echo -e "${RED}错误: 本地 Registry 未启动！${NC}"
+    echo "请执行: sudo docker run -d -p 5000:5000 --restart=always --name registry registry:2"
+    exit 1
+fi
+
+# ==============================================================================
+# 1. 构建 Base Builder
+# ==============================================================================
+echo -e "${YELLOW}[1/3] 构建 Base Builder...${NC}"
+# 注意：这里路径保持 docker/xxx，因为我们已经 cd 到了根目录
+sudo docker buildx build \
+  --platform linux/amd64,linux/arm64 \
+  -t "${BASE_IMAGE}" \
+  -f docker/ubuntu24.04-base-builder-dockerfile \
+  --build-arg FALCONFS_TAG="${BRANCH_TAG}" \
+  --build-arg GIT_USERNAME="${GIT_USER}" \
+  --build-arg GIT_TOKEN="${GIT_TOKEN}" \
+  --pull \
+  --no-cache \
+  . \
+  --push
+
+echo -e "${GREEN}✔ Base Builder 完成${NC}"
+
+# ==============================================================================
+# 2. 自动修改 Dockerfile 依赖
+# ==============================================================================
+echo -e "${YELLOW}[INFO] 更新 CN/DN Dockerfile 指向: ${BASE_IMAGE}${NC}"
+
+sed -i "s|FROM .* AS builder|FROM ${BASE_IMAGE} AS builder|g" docker/ubuntu24.04-cn-dockerfile
+sed -i "s|FROM .* AS builder|FROM ${BASE_IMAGE} AS builder|g" docker/ubuntu24.04-dn-dockerfile
+
+# ==============================================================================
+# 3. 构建 CN 和 DN
+# ==============================================================================
+echo -e "${YELLOW}[2/3] 构建 CN...${NC}"
+sudo docker buildx build \
+  --platform linux/amd64,linux/arm64 \ 
+  -t "${CN_IMAGE}" \  
+  -f docker/ubuntu24.04-cn-dockerfile \
+  --pull \
+  --no-cache \
+  . \
+  --push
+
+echo -e "${YELLOW}[3/3] 构建 DN...${NC}"
+sudo docker buildx build \
+  --platform linux/amd64,linux/arm64 \
+  -t "${DN_IMAGE}" \
+  -f docker/ubuntu24.04-dn-dockerfile \
+  --pull \
+  --no-cache \
+  . \
+  --push
+
+echo -e "${GREEN}============================================================${NC}"
+echo -e "${GREEN}所有构建完成！${NC}"
+echo -e "${GREEN}============================================================${NC}"   
diff --git a/docker/ubuntu24.04-cn-dockerfile b/docker/ubuntu24.04-cn-dockerfile
index aeb5a52..2ba5199 100644
--- a/docker/ubuntu24.04-cn-dockerfile
+++ b/docker/ubuntu24.04-cn-dockerfile
@@ -26,6 +26,7 @@ COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_nati
 COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_native/docker_build/cn/stop.sh /home/falconMeta/
 COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_native/docker_build/cn/check_liveness.sh /home/falconMeta/
 COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_native/docker_build/cn/rm_logs.sh /home/falconMeta/
+COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_native/docker_build/cn/postgresql_falcon.conf /home/falconMeta/
 
 # 创建必要的目录
 RUN mkdir -p /home/falconMeta/readiness/ /home/falconMeta/data/
diff --git a/docker/ubuntu24.04-dn-dockerfile b/docker/ubuntu24.04-dn-dockerfile
index 8131c1f..a3f6119 100644
--- a/docker/ubuntu24.04-dn-dockerfile
+++ b/docker/ubuntu24.04-dn-dockerfile
@@ -26,6 +26,7 @@ COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_nati
 COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_native/docker_build/dn/stop.sh /home/falconMeta/
 COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_native/docker_build/dn/check_liveness.sh /home/falconMeta/
 COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_native/docker_build/dn/rm_logs.sh /home/falconMeta/
+COPY --chown=$USER_NAME:$USER_NAME --from=builder /root/code/falconfs/cloud_native/docker_build/dn/postgresql_falcon.conf /home/falconMeta/
 
 # 创建必要的目录
 RUN mkdir -p /home/falconMeta/readiness/ /home/falconMeta/data/
diff --git a/falcon/Makefile b/falcon/Makefile
index 11b6868..266ee64 100644
--- a/falcon/Makefile
+++ b/falcon/Makefile
@@ -3,11 +3,12 @@
 PG_CFLAGS = -Wno-declaration-after-statement
 
 MODULE_big = falcon
-SUBDIRS = . metadb utils distributed_backend transaction control dir_path_shmem connection_pool
+SUBDIRS = . metadb utils distributed_backend transaction control dir_path_shmem connection_pool plugin
 
 falcon_srcdir = .
 CXX_OBJS += \
 	$(patsubst $(falcon_srcdir)/%.cpp,%.o,$(foreach dir,$(SUBDIRS), $(sort $(wildcard $(falcon_srcdir)/$(dir)/*.cpp))))
+# Plugin sources are included in SUBDIRS above
 OBJS += \
 	$(patsubst $(falcon_srcdir)/%.c,%.o,$(foreach dir,$(SUBDIRS), $(sort $(wildcard $(falcon_srcdir)/$(dir)/*.c))))
 OBJS += $(CXX_OBJS)
diff --git a/falcon/connection_pool/connection_pool.c b/falcon/connection_pool/connection_pool.c
index 75f3592..f8de850 100644
--- a/falcon/connection_pool/connection_pool.c
+++ b/falcon/connection_pool/connection_pool.c
@@ -31,6 +31,7 @@ int FalconConnectionPoolWaitAdjust = FALCON_CONNECTION_POOL_WAIT_ADJUST_DEFAULT;
 int FalconConnectionPoolWaitMin = FALCON_CONNECTION_POOL_WAIT_MIN_DEFAULT;
 int FalconConnectionPoolWaitMax = FALCON_CONNECTION_POOL_WAIT_MAX_DEFAULT;
 uint64_t FalconConnectionPoolShmemSize = FALCON_CONNECTION_POOL_SHMEM_SIZE_DEFAULT;
+char *FalconNodeLocalIp = NULL;
 static char *FalconConnectionPoolShmemBuffer = NULL;
 FalconShmemAllocator FalconConnectionPoolShmemAllocator;
 
diff --git a/falcon/connection_pool/falcon_meta_service.cpp b/falcon/connection_pool/falcon_meta_service.cpp
new file mode 100644
index 0000000..a78b4b1
--- /dev/null
+++ b/falcon/connection_pool/falcon_meta_service.cpp
@@ -0,0 +1,908 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#include "connection_pool/falcon_meta_service_internal.h"
+#include "connection_pool/pg_connection.h"
+#include "connection_pool/connection_pool_config.h"
+#include "connection_pool/pg_connection_pool.h"
+#include "falcon_meta_rpc.pb.h"
+#include "falcon_meta_param_generated.h"
+#include "falcon_meta_response_generated.h"
+#include "connection_pool/task.h"
+#include <brpc/controller.h>
+#include <google/protobuf/stubs/callback.h>
+#include <cstring>
+#include <cstdlib>
+#include <vector>
+#include <mutex>
+
+extern "C" {
+#define FALCON_REMOTE_CONNECTION_DEF_SERIALIZED_DATA_IMPLEMENT
+#include "remote_connection_utils/serialized_data.h"
+}
+
+namespace falcon {
+namespace meta_service {
+
+static void HandleFalconMetaResponse(brpc::Controller* cntl,
+                                     falcon::meta_proto::Empty* proto_response,
+                                     AsyncFalconMetaServiceJob* original_job)
+{
+    FalconMetaServiceResponse& response = original_job->GetResponse();
+    response.opcode = original_job->GetRequest().operation;
+
+    if (cntl->Failed()) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] RPC failed: %s\n", cntl->ErrorText().c_str());
+        response.status = -1;
+        response.data = nullptr;
+    } else {
+        if (!FalconMetaServiceSerializer::DeserializeResponseFromFlatBuffers(
+                cntl->response_attachment(),
+                &response,
+                original_job->GetRequest().operation)) {
+            fprintf(stderr, "[WARNING] [FalconMetaService] Failed to deserialize response for opcode=%d\n",
+                 static_cast<int>(original_job->GetRequest().operation));
+            response.status = -1;
+        }
+    }
+
+    original_job->Done();
+
+    delete cntl;
+    delete proto_response;
+    delete original_job;
+}
+
+}  // namespace meta_service
+}  // namespace falcon
+
+namespace falcon {
+namespace meta_service {
+
+FalconMetaService* FalconMetaService::instance = nullptr;
+std::mutex FalconMetaService::instanceMutex;
+
+FalconMetaService::FalconMetaService() : initialized(false)
+{
+}
+
+FalconMetaService* FalconMetaService::Instance()
+{
+    std::lock_guard<std::mutex> lock(instanceMutex);
+    if (instance == nullptr) {
+        instance = new FalconMetaService();
+    }
+    return instance;
+}
+
+bool FalconMetaService::Init(int port, int pool_size)
+{
+    std::lock_guard<std::mutex> lock(instanceMutex);
+
+    if (initialized) {
+        return true;
+    }
+
+    if (port <= 0 || port > 65535) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] Invalid port number: %d\n", port);
+        return false;
+    }
+
+    if (pool_size <= 0) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] Invalid pool size: %d\n", pool_size);
+        return false;
+    }
+
+    char* user_name = getenv("USER");
+    if (!user_name) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] Cannot get USER from environment\n");
+        return false;
+    }
+
+    try {
+        pgConnectionPool = std::make_shared<PGConnectionPool>(
+            port, user_name, pool_size, 20, 400);
+
+        fprintf(stderr, "[LOG] [FalconMetaService] Initialized with: port=%d, user=%s, poolSize=%d\n",
+             port, user_name, pool_size);
+
+        initialized = true;
+        return true;
+    } catch (const std::exception& e) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] Failed to initialize connection pool: %s\n", e.what());
+        return false;
+    }
+}
+
+FalconMetaService::~FalconMetaService()
+{
+    if (pgConnectionPool) {
+        pgConnectionPool->Stop();
+        pgConnectionPool.reset();
+    }
+}
+
+int FalconMetaService::DispatchFalconMetaServiceJob(AsyncFalconMetaServiceJob* job)
+{
+    if (pgConnectionPool == nullptr) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] DispatchJob failed: connection pool is null\n");
+        if (job != nullptr) {
+            job->GetResponse().status = -1;
+            job->Done();
+            delete job;
+        }
+        return -1;
+    }
+
+    FalconMetaServiceRequest& request = job->GetRequest();
+
+    fprintf(stderr, "[LOG] [FalconMetaService] DispatchFalconMetaServiceJob: opcode=%d(%s)\n",
+         static_cast<int>(request.operation),
+         FalconMetaOperationTypeName(request.operation));
+
+    brpc::Controller* cntl = new brpc::Controller();
+    falcon::meta_proto::MetaRequest* proto_request = new falcon::meta_proto::MetaRequest();
+    falcon::meta_proto::Empty* proto_response = new falcon::meta_proto::Empty();
+
+    FalconErrorCode serializeError = FalconMetaServiceSerializer::SerializeRequestToFlatBuffers(
+            request, proto_request, &cntl->request_attachment());
+    if (serializeError != SUCCESS) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] Failed to serialize request for opcode=%d, error=%d\n",
+             static_cast<int>(request.operation), static_cast<int>(serializeError));
+        job->GetResponse().status = serializeError;
+        job->Done();
+        delete job;
+        delete cntl;
+        delete proto_request;
+        delete proto_response;
+        return -1;
+    }
+
+    google::protobuf::Closure* done_callback = brpc::NewCallback(
+        &HandleFalconMetaResponse, cntl, proto_response, job);
+
+    falcon::meta_proto::AsyncMetaServiceJob* brpc_job =
+        new falcon::meta_proto::AsyncMetaServiceJob(cntl, proto_request, proto_response, done_callback);
+
+    pgConnectionPool->DispatchAsyncMetaServiceJob(brpc_job);
+
+    return 0;
+}
+
+int FalconMetaService::SubmitFalconMetaRequest(const FalconMetaServiceRequest& request,
+                                               FalconMetaServiceCallback callback,
+                                               void* user_context)
+{
+    if (!initialized) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] Service not initialized. Call Init() first.\n");
+        return -1;
+    }
+
+    fprintf(stderr, "[LOG] [FalconMetaService] SubmitFalconMetaRequest: opcode=%d(%s)\n",
+         static_cast<int>(request.operation),
+         FalconMetaOperationTypeName(request.operation));
+
+    AsyncFalconMetaServiceJob* job = new AsyncFalconMetaServiceJob(request, callback, user_context);
+
+    return DispatchFalconMetaServiceJob(job);
+}
+
+static falcon::meta_proto::MetaServiceType ConvertToProtoType(FalconMetaOperationType op)
+{
+    switch (op) {
+        case DFC_PUT_KEY_META: return falcon::meta_proto::MetaServiceType::KV_PUT;
+        case DFC_GET_KV_META: return falcon::meta_proto::MetaServiceType::KV_GET;
+        case DFC_DELETE_KV_META: return falcon::meta_proto::MetaServiceType::KV_DEL;
+        case DFC_MKDIR: return falcon::meta_proto::MetaServiceType::MKDIR;
+        case DFC_MKDIR_SUB_MKDIR: return falcon::meta_proto::MetaServiceType::MKDIR_SUB_MKDIR;
+        case DFC_MKDIR_SUB_CREATE: return falcon::meta_proto::MetaServiceType::MKDIR_SUB_CREATE;
+        case DFC_CREATE: return falcon::meta_proto::MetaServiceType::CREATE;
+        case DFC_STAT: return falcon::meta_proto::MetaServiceType::STAT;
+        case DFC_OPEN: return falcon::meta_proto::MetaServiceType::OPEN;
+        case DFC_CLOSE: return falcon::meta_proto::MetaServiceType::CLOSE;
+        case DFC_UNLINK: return falcon::meta_proto::MetaServiceType::UNLINK;
+        case DFC_READDIR: return falcon::meta_proto::MetaServiceType::READDIR;
+        case DFC_OPENDIR: return falcon::meta_proto::MetaServiceType::OPENDIR;
+        case DFC_RMDIR: return falcon::meta_proto::MetaServiceType::RMDIR;
+        case DFC_RMDIR_SUB_RMDIR: return falcon::meta_proto::MetaServiceType::RMDIR_SUB_RMDIR;
+        case DFC_RMDIR_SUB_UNLINK: return falcon::meta_proto::MetaServiceType::RMDIR_SUB_UNLINK;
+        case DFC_RENAME: return falcon::meta_proto::MetaServiceType::RENAME;
+        case DFC_RENAME_SUB_RENAME_LOCALLY: return falcon::meta_proto::MetaServiceType::RENAME_SUB_RENAME_LOCALLY;
+        case DFC_RENAME_SUB_CREATE: return falcon::meta_proto::MetaServiceType::RENAME_SUB_CREATE;
+        case DFC_UTIMENS: return falcon::meta_proto::MetaServiceType::UTIMENS;
+        case DFC_CHOWN: return falcon::meta_proto::MetaServiceType::CHOWN;
+        case DFC_CHMOD: return falcon::meta_proto::MetaServiceType::CHMOD;
+        case DFC_SLICE_PUT: return falcon::meta_proto::MetaServiceType::SLICE_PUT;
+        case DFC_SLICE_GET: return falcon::meta_proto::MetaServiceType::SLICE_GET;
+        case DFC_SLICE_DEL: return falcon::meta_proto::MetaServiceType::SLICE_DEL;
+        case DFC_FETCH_SLICE_ID: return falcon::meta_proto::MetaServiceType::FETCH_SLICE_ID;
+        default: return falcon::meta_proto::MetaServiceType::PLAIN_COMMAND;
+    }
+}
+
+static bool ValidateNameLength(const std::string& name) {
+    return name.length() <= FALCON_MAX_NAME_LENGTH;
+}
+
+static bool ValidatePathComponentLengths(const std::string& path) {
+    if (path.empty()) return true;
+
+    size_t start = 0;
+    if (path[0] == '/') start = 1;
+
+    size_t pos;
+    while ((pos = path.find('/', start)) != std::string::npos) {
+        if (pos > start && (pos - start) > FALCON_MAX_NAME_LENGTH) {
+            return false;
+        }
+        start = pos + 1;
+    }
+    if (path.length() > start && (path.length() - start) > FALCON_MAX_NAME_LENGTH) {
+        return false;
+    }
+    return true;
+}
+
+FalconErrorCode FalconMetaServiceSerializer::SerializeRequestToFlatBuffers(
+    const FalconMetaServiceRequest& request,
+    falcon::meta_proto::MetaRequest* proto_request,
+    butil::IOBuf* attachment)
+{
+    falcon::meta_proto::MetaServiceType proto_type = ConvertToProtoType(request.operation);
+    proto_request->add_type(proto_type);
+
+    if (proto_type == falcon::meta_proto::MKDIR ||
+        proto_type == falcon::meta_proto::CREATE ||
+        proto_type == falcon::meta_proto::STAT ||
+        proto_type == falcon::meta_proto::OPEN ||
+        proto_type == falcon::meta_proto::CLOSE ||
+        proto_type == falcon::meta_proto::UNLINK) {
+        proto_request->set_allow_batch_with_others(true);
+    }
+
+    flatbuffers::FlatBufferBuilder builder(1024);
+    flatbuffers::Offset<falcon::meta_fbs::MetaParam> meta_param;
+
+    switch (request.operation) {
+        case DFC_MKDIR:
+        case DFC_CREATE:
+        case DFC_STAT:
+        case DFC_OPEN:
+        case DFC_UNLINK:
+        case DFC_OPENDIR:
+        case DFC_RMDIR: {
+            const PathOnlyParam* param = meta_param_helper::Get<PathOnlyParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidatePathComponentLengths(param->path)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Path component exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->path.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto path = builder.CreateString(param->path);
+            auto fbs_param = falcon::meta_fbs::CreatePathOnlyParam(builder, path);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_PathOnlyParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_CLOSE: {
+            const CloseParam* param = meta_param_helper::Get<CloseParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidatePathComponentLengths(param->path)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Path component exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->path.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto path = builder.CreateString(param->path);
+            auto fbs_param = falcon::meta_fbs::CreateCloseParam(builder, path,
+                param->st_size, param->st_mtim, param->node_id);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_CloseParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_READDIR: {
+            const ReadDirParam* param = meta_param_helper::Get<ReadDirParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidatePathComponentLengths(param->path)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Path component exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->path.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto path = builder.CreateString(param->path);
+            auto last_file_name = builder.CreateString(param->last_file_name);
+            auto fbs_param = falcon::meta_fbs::CreateReadDirParam(builder, path,
+                param->max_read_count, param->last_shard_index, last_file_name);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_ReadDirParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_MKDIR_SUB_MKDIR: {
+            const MkdirSubMkdirParam* param = meta_param_helper::Get<MkdirSubMkdirParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidateNameLength(param->name)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Name exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->name.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto name = builder.CreateString(param->name);
+            auto fbs_param = falcon::meta_fbs::CreateMkdirSubMkdirParam(builder,
+                param->parent_id, name, param->inode_id);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_MkdirSubMkdirParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_MKDIR_SUB_CREATE: {
+            const MkdirSubCreateParam* param = meta_param_helper::Get<MkdirSubCreateParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidateNameLength(param->name)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Name exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->name.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto name = builder.CreateString(param->name);
+            auto fbs_param = falcon::meta_fbs::CreateMkdirSubCreateParam(builder,
+                param->parent_id_part_id, name, param->inode_id, param->st_mode,
+                param->st_mtim, param->st_size);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_MkdirSubCreateParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_RMDIR_SUB_RMDIR: {
+            const RmdirSubRmdirParam* param = meta_param_helper::Get<RmdirSubRmdirParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidateNameLength(param->name)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Name exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->name.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto name = builder.CreateString(param->name);
+            auto fbs_param = falcon::meta_fbs::CreateRmdirSubRmdirParam(builder, param->parent_id, name);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_RmdirSubRmdirParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_RMDIR_SUB_UNLINK: {
+            const RmdirSubUnlinkParam* param = meta_param_helper::Get<RmdirSubUnlinkParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidateNameLength(param->name)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Name exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->name.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto name = builder.CreateString(param->name);
+            auto fbs_param = falcon::meta_fbs::CreateRmdirSubUnlinkParam(builder,
+                param->parent_id_part_id, name);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_RmdirSubUnlinkParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_RENAME: {
+            const RenameParam* param = meta_param_helper::Get<RenameParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidatePathComponentLengths(param->src)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Source path component exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->src.c_str());
+                return INVALID_PARAMETER;
+            }
+            if (!ValidatePathComponentLengths(param->dst)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Destination path component exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->dst.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto src = builder.CreateString(param->src);
+            auto dst = builder.CreateString(param->dst);
+            auto fbs_param = falcon::meta_fbs::CreateRenameParam(builder, src, dst);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_RenameParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_RENAME_SUB_RENAME_LOCALLY: {
+            const RenameSubRenameLocallyParam* param = meta_param_helper::Get<RenameSubRenameLocallyParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidateNameLength(param->src_name)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Source name exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->src_name.c_str());
+                return INVALID_PARAMETER;
+            }
+            if (!ValidateNameLength(param->dst_name)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Destination name exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->dst_name.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto src_name = builder.CreateString(param->src_name);
+            auto dst_name = builder.CreateString(param->dst_name);
+            auto fbs_param = falcon::meta_fbs::CreateRenameSubRenameLocallyParam(builder,
+                param->src_parent_id, param->src_parent_id_part_id, src_name,
+                param->dst_parent_id, param->dst_parent_id_part_id, dst_name,
+                param->target_is_directory, param->directory_inode_id, param->src_lock_order);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_RenameSubRenameLocallyParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_RENAME_SUB_CREATE: {
+            const RenameSubCreateParam* param = meta_param_helper::Get<RenameSubCreateParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidateNameLength(param->name)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Name exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->name.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto name = builder.CreateString(param->name);
+            auto fbs_param = falcon::meta_fbs::CreateRenameSubCreateParam(builder,
+                param->parentid_partid, name, param->st_ino, param->st_dev, param->st_mode,
+                param->st_nlink, param->st_uid, param->st_gid, param->st_rdev, param->st_size,
+                param->st_blksize, param->st_blocks, param->st_atim, param->st_mtim,
+                param->st_ctim, param->node_id);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_RenameSubCreateParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_UTIMENS: {
+            const UtimeNsParam* param = meta_param_helper::Get<UtimeNsParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidatePathComponentLengths(param->path)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Path component exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->path.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto path = builder.CreateString(param->path);
+            auto fbs_param = falcon::meta_fbs::CreateUtimeNsParam(builder, path,
+                param->st_atim, param->st_mtim);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_UtimeNsParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_CHOWN: {
+            const ChownParam* param = meta_param_helper::Get<ChownParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidatePathComponentLengths(param->path)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Path component exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->path.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto path = builder.CreateString(param->path);
+            auto fbs_param = falcon::meta_fbs::CreateChownParam(builder, path,
+                param->st_uid, param->st_gid);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_ChownParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_CHMOD: {
+            const ChmodParam* param = meta_param_helper::Get<ChmodParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            if (!ValidatePathComponentLengths(param->path)) {
+                fprintf(stderr, "[WARNING] [FalconMetaService] Path component exceeds %zu bytes: %s\n",
+                     FALCON_MAX_NAME_LENGTH, param->path.c_str());
+                return INVALID_PARAMETER;
+            }
+            auto path = builder.CreateString(param->path);
+            auto fbs_param = falcon::meta_fbs::CreateChmodParam(builder, path, param->st_mode);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_ChmodParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_PUT_KEY_META: {
+            std::vector<uint64_t> value_keys, locations;
+            std::vector<uint32_t> sizes;
+            for (const auto& slice : request.kv_data.dataSlices) {
+                value_keys.push_back(slice.value_key);
+                locations.push_back(slice.location);
+                sizes.push_back(slice.size);
+            }
+            auto key = builder.CreateString(request.kv_data.key);
+            auto vk_vec = builder.CreateVector(value_keys);
+            auto loc_vec = builder.CreateVector(locations);
+            auto sz_vec = builder.CreateVector(sizes);
+            auto fbs_param = falcon::meta_fbs::CreateKVParam(builder, key,
+                request.kv_data.valueLen, request.kv_data.sliceNum, vk_vec, loc_vec, sz_vec);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_KVParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_GET_KV_META:
+        case DFC_DELETE_KV_META: {
+            auto key = builder.CreateString(request.kv_data.key);
+            auto fbs_param = falcon::meta_fbs::CreateKeyOnlyParam(builder, key);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_KeyOnlyParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_PLAIN_COMMAND: {
+            const PlainCommandParam* param = meta_param_helper::Get<PlainCommandParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            auto command = builder.CreateString(param->command);
+            auto fbs_param = falcon::meta_fbs::CreatePlainCommandParam(builder, command);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_PlainCommandParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_SLICE_GET:
+        case DFC_SLICE_DEL: {
+            const SliceIndexParam* param = meta_param_helper::Get<SliceIndexParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            auto filename = builder.CreateString(param->filename);
+            auto fbs_param = falcon::meta_fbs::CreateSliceIndexParam(builder, filename,
+                param->inodeid, param->chunkid);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_SliceIndexParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_SLICE_PUT: {
+            const SliceInfoParam* param = meta_param_helper::Get<SliceInfoParam>(request.file_params);
+            if (!param) return ARGUMENT_ERROR;
+            auto filename = builder.CreateString(param->filename);
+            auto inodeid_vec = builder.CreateVector(param->inodeid);
+            auto chunkid_vec = builder.CreateVector(param->chunkid);
+            auto sliceid_vec = builder.CreateVector(param->sliceid);
+            auto slicesize_vec = builder.CreateVector(param->slicesize);
+            auto sliceoffset_vec = builder.CreateVector(param->sliceoffset);
+            auto slicelen_vec = builder.CreateVector(param->slicelen);
+            auto sliceloc1_vec = builder.CreateVector(param->sliceloc1);
+            auto sliceloc2_vec = builder.CreateVector(param->sliceloc2);
+            auto fbs_param = falcon::meta_fbs::CreateSliceInfoParam(builder, filename,
+                param->slicenum, inodeid_vec, chunkid_vec, sliceid_vec, slicesize_vec,
+                sliceoffset_vec, slicelen_vec, sliceloc1_vec, sliceloc2_vec);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_SliceInfoParam, fbs_param.Union());
+            break;
+        }
+
+        case DFC_FETCH_SLICE_ID: {
+            auto fbs_param = falcon::meta_fbs::CreateSliceIdParam(builder,
+                request.sliceid_param.count, request.sliceid_param.type);
+            meta_param = falcon::meta_fbs::CreateMetaParam(builder,
+                falcon::meta_fbs::AnyMetaParam_SliceIdParam, fbs_param.Union());
+            break;
+        }
+
+        default:
+            return ARGUMENT_ERROR;
+    }
+
+    builder.Finish(meta_param);
+
+    SerializedData sd;
+    SerializedDataInit(&sd, NULL, 0, 0, NULL);
+    char* buf = SerializedDataApplyForSegment(&sd, builder.GetSize());
+    if (!buf) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] SerializeRequest: failed to allocate buffer, size=%u\n",
+             builder.GetSize());
+        return OUT_OF_MEMORY;
+    }
+    memcpy(buf, builder.GetBufferPointer(), builder.GetSize());
+
+    attachment->append(sd.buffer, sd.size);
+    SerializedDataDestroy(&sd);
+
+    return SUCCESS;
+}
+
+bool FalconMetaServiceSerializer::DeserializeResponseFromFlatBuffers(
+    const butil::IOBuf& attachment,
+    FalconMetaServiceResponse* response,
+    FalconMetaOperationType operation)
+{
+    if (attachment.size() < sizeof(sd_size_t)) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] DeserializeResponse: attachment too small, size=%zu\n",
+             attachment.size());
+        return false;
+    }
+
+    std::vector<char> buffer(attachment.size());
+    attachment.copy_to(&buffer[0], attachment.size());
+
+    SerializedData sd;
+    if (!SerializedDataInit(&sd, &buffer[0], buffer.size(), buffer.size(), NULL)) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] DeserializeResponse: SerializedDataInit failed\n");
+        return false;
+    }
+
+    sd_size_t item_size = SerializedDataNextSeveralItemSize(&sd, 0, 1);
+    if (item_size == (sd_size_t)-1) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] DeserializeResponse: invalid item size\n");
+        return false;
+    }
+
+    char* fbs_data = &buffer[0] + SERIALIZED_DATA_ALIGNMENT;
+    sd_size_t fbs_size = *(sd_size_t*)&buffer[0];
+    if (!SystemIsLittleEndian()) {
+        fbs_size = ConvertBetweenBigAndLittleEndian(fbs_size);
+    }
+
+    flatbuffers::Verifier verifier((uint8_t*)fbs_data, fbs_size);
+    if (!verifier.VerifyBuffer<falcon::meta_fbs::MetaResponse>()) {
+        fprintf(stderr, "[WARNING] [FalconMetaService] DeserializeResponse: FlatBuffers verification failed\n");
+        return false;
+    }
+
+    const falcon::meta_fbs::MetaResponse* meta_response = falcon::meta_fbs::GetMetaResponse(fbs_data);
+    response->opcode = operation;
+    response->status = meta_response->error_code();
+
+    if (response->status != SUCCESS) {
+        fprintf(stderr, "[LOG] [FalconMetaService] DeserializeResponse: opcode=%d, error_code=%d, creating empty response\n",
+             static_cast<int>(operation), response->status);
+
+        switch (operation) {
+            case DFC_CREATE: {
+                response->data = new CreateResponse();
+                memset(response->data, 0, sizeof(CreateResponse));
+                return true;
+            }
+            case DFC_STAT: {
+                response->data = new StatResponse();
+                memset(response->data, 0, sizeof(StatResponse));
+                return true;
+            }
+            case DFC_OPEN: {
+                response->data = new OpenResponse();
+                memset(response->data, 0, sizeof(OpenResponse));
+                return true;
+            }
+            case DFC_UNLINK: {
+                response->data = new UnlinkResponse();
+                memset(response->data, 0, sizeof(UnlinkResponse));
+                return true;
+            }
+            case DFC_READDIR: {
+                response->data = new ReadDirResponse();
+                memset(response->data, 0, sizeof(ReadDirResponse));
+                return true;
+            }
+            case DFC_OPENDIR: {
+                response->data = new OpenDirResponse();
+                memset(response->data, 0, sizeof(OpenDirResponse));
+                return true;
+            }
+            case DFC_GET_KV_META: {
+                response->data = new KvDataResponse();
+                memset(response->data, 0, sizeof(KvDataResponse));
+                return true;
+            }
+            case DFC_SLICE_GET: {
+                response->data = new SliceInfoResponse();
+                memset(response->data, 0, sizeof(SliceInfoResponse));
+                return true;
+            }
+            case DFC_PLAIN_COMMAND: {
+                response->data = new PlainCommandResponse();
+                memset(response->data, 0, sizeof(PlainCommandResponse));
+                return true;
+            }
+            default:
+                response->data = nullptr;
+                return true;
+        }
+    }
+
+    switch (operation) {
+        case DFC_MKDIR:
+        case DFC_RMDIR:
+        case DFC_CLOSE:
+        case DFC_RENAME:
+        case DFC_UTIMENS:
+        case DFC_CHOWN:
+        case DFC_CHMOD:
+        case DFC_PUT_KEY_META:
+        case DFC_DELETE_KV_META:
+        case DFC_SLICE_PUT:
+        case DFC_SLICE_DEL:
+            response->data = nullptr;
+            return true;
+
+        case DFC_CREATE: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_CreateResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_CreateResponse();
+            CreateResponse* create_resp = new CreateResponse();
+            create_resp->st_ino = fbs_resp->st_ino();
+            create_resp->node_id = fbs_resp->node_id();
+            create_resp->st_dev = fbs_resp->st_dev();
+            create_resp->st_mode = fbs_resp->st_mode();
+            create_resp->st_nlink = fbs_resp->st_nlink();
+            create_resp->st_uid = fbs_resp->st_uid();
+            create_resp->st_gid = fbs_resp->st_gid();
+            create_resp->st_rdev = fbs_resp->st_rdev();
+            create_resp->st_size = fbs_resp->st_size();
+            create_resp->st_blksize = fbs_resp->st_blksize();
+            create_resp->st_blocks = fbs_resp->st_blocks();
+            create_resp->st_atim = fbs_resp->st_atim();
+            create_resp->st_mtim = fbs_resp->st_mtim();
+            create_resp->st_ctim = fbs_resp->st_ctim();
+            response->data = create_resp;
+            return true;
+        }
+
+        case DFC_STAT: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_StatResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_StatResponse();
+            StatResponse* stat_resp = new StatResponse();
+            stat_resp->st_ino = fbs_resp->st_ino();
+            stat_resp->st_dev = fbs_resp->st_dev();
+            stat_resp->st_mode = fbs_resp->st_mode();
+            stat_resp->st_nlink = fbs_resp->st_nlink();
+            stat_resp->st_uid = fbs_resp->st_uid();
+            stat_resp->st_gid = fbs_resp->st_gid();
+            stat_resp->st_rdev = fbs_resp->st_rdev();
+            stat_resp->st_size = fbs_resp->st_size();
+            stat_resp->st_blksize = fbs_resp->st_blksize();
+            stat_resp->st_blocks = fbs_resp->st_blocks();
+            stat_resp->st_atim = fbs_resp->st_atim();
+            stat_resp->st_mtim = fbs_resp->st_mtim();
+            stat_resp->st_ctim = fbs_resp->st_ctim();
+            response->data = stat_resp;
+            return true;
+        }
+
+        case DFC_OPEN: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_OpenResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_OpenResponse();
+            OpenResponse* open_resp = new OpenResponse();
+            open_resp->st_ino = fbs_resp->st_ino();
+            open_resp->node_id = fbs_resp->node_id();
+            open_resp->st_dev = fbs_resp->st_dev();
+            open_resp->st_mode = fbs_resp->st_mode();
+            open_resp->st_nlink = fbs_resp->st_nlink();
+            open_resp->st_uid = fbs_resp->st_uid();
+            open_resp->st_gid = fbs_resp->st_gid();
+            open_resp->st_rdev = fbs_resp->st_rdev();
+            open_resp->st_size = fbs_resp->st_size();
+            open_resp->st_blksize = fbs_resp->st_blksize();
+            open_resp->st_blocks = fbs_resp->st_blocks();
+            open_resp->st_atim = fbs_resp->st_atim();
+            open_resp->st_mtim = fbs_resp->st_mtim();
+            open_resp->st_ctim = fbs_resp->st_ctim();
+            response->data = open_resp;
+            return true;
+        }
+
+        case DFC_UNLINK: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_UnlinkResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_UnlinkResponse();
+            UnlinkResponse* unlink_resp = new UnlinkResponse();
+            unlink_resp->st_ino = fbs_resp->st_ino();
+            unlink_resp->st_size = fbs_resp->st_size();
+            unlink_resp->node_id = fbs_resp->node_id();
+            response->data = unlink_resp;
+            return true;
+        }
+
+        case DFC_OPENDIR: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_OpenDirResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_OpenDirResponse();
+            OpenDirResponse* opendir_resp = new OpenDirResponse();
+            opendir_resp->st_ino = fbs_resp->st_ino();
+            response->data = opendir_resp;
+            return true;
+        }
+
+        case DFC_READDIR: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_ReadDirResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_ReadDirResponse();
+            ReadDirResponse* readdir_resp = new ReadDirResponse();
+            readdir_resp->last_shard_index = fbs_resp->last_shard_index();
+            if (fbs_resp->last_file_name()) {
+                readdir_resp->last_file_name = fbs_resp->last_file_name()->str();
+            }
+            if (fbs_resp->result_list()) {
+                for (const auto* entry : *fbs_resp->result_list()) {
+                    OneReadDirResponse one_entry;
+                    if (entry->file_name()) {
+                        one_entry.file_name = entry->file_name()->str();
+                    }
+                    one_entry.st_mode = entry->st_mode();
+                    readdir_resp->result_list.push_back(one_entry);
+                }
+            }
+            response->data = readdir_resp;
+            return true;
+        }
+
+        case DFC_GET_KV_META: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_GetKVMetaResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_GetKVMetaResponse();
+            KvDataResponse* kv_resp = new KvDataResponse();
+            kv_resp->kv_data.valueLen = fbs_resp->value_len();
+            kv_resp->kv_data.sliceNum = fbs_resp->slice_num();
+            if (fbs_resp->value_key() && fbs_resp->location() && fbs_resp->size()) {
+                for (size_t i = 0; i < fbs_resp->value_key()->size(); ++i) {
+                    FormDataSlice slice;
+                    slice.value_key = fbs_resp->value_key()->Get(i);
+                    slice.location = fbs_resp->location()->Get(i);
+                    slice.size = fbs_resp->size()->Get(i);
+                    kv_resp->kv_data.dataSlices.push_back(slice);
+                }
+            }
+            response->data = kv_resp;
+            return true;
+        }
+
+        case DFC_SLICE_GET: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_SliceInfoResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_SliceInfoResponse();
+            SliceInfoResponse* slice_resp = new SliceInfoResponse();
+            slice_resp->slicenum = fbs_resp->slicenum();
+            if (fbs_resp->inodeid()) {
+                for (size_t i = 0; i < fbs_resp->inodeid()->size(); ++i) {
+                    slice_resp->inodeid.push_back(fbs_resp->inodeid()->Get(i));
+                    slice_resp->chunkid.push_back(fbs_resp->chunkid()->Get(i));
+                    slice_resp->sliceid.push_back(fbs_resp->sliceid()->Get(i));
+                    slice_resp->slicesize.push_back(fbs_resp->slicesize()->Get(i));
+                    slice_resp->sliceoffset.push_back(fbs_resp->sliceoffset()->Get(i));
+                    slice_resp->slicelen.push_back(fbs_resp->slicelen()->Get(i));
+                    slice_resp->sliceloc1.push_back(fbs_resp->sliceloc1()->Get(i));
+                    slice_resp->sliceloc2.push_back(fbs_resp->sliceloc2()->Get(i));
+                }
+            }
+            response->data = slice_resp;
+            return true;
+        }
+
+        case DFC_FETCH_SLICE_ID: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_SliceIdResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_SliceIdResponse();
+            SliceIdResponse* sliceid_resp = new SliceIdResponse();
+            sliceid_resp->start = fbs_resp->startid();
+            sliceid_resp->end = fbs_resp->endid();
+            response->data = sliceid_resp;
+            return true;
+        }
+
+        case DFC_PLAIN_COMMAND: {
+            if (meta_response->response_type() != falcon::meta_fbs::AnyMetaResponse_PlainCommandResponse) {
+                return false;
+            }
+            const auto* fbs_resp = meta_response->response_as_PlainCommandResponse();
+            PlainCommandResponse* plain_resp = new PlainCommandResponse();
+            plain_resp->row = fbs_resp->row();
+            plain_resp->col = fbs_resp->col();
+            if (fbs_resp->data()) {
+                for (const auto* item : *fbs_resp->data()) {
+                    plain_resp->data.push_back(item->str());
+                }
+            }
+            response->data = plain_resp;
+            return true;
+        }
+
+        default:
+            return false;
+    }
+}
+
+} // namespace meta_service
+} // namespace falcon
diff --git a/falcon/distributed_backend/distributed_backend_falcon.c b/falcon/distributed_backend/distributed_backend_falcon.c
index aebf5fc..ca14381 100644
--- a/falcon/distributed_backend/distributed_backend_falcon.c
+++ b/falcon/distributed_backend/distributed_backend_falcon.c
@@ -13,6 +13,8 @@
 #include "utils/utils.h"
 
 PG_FUNCTION_INFO_V1(falcon_create_distributed_data_table);
+PG_FUNCTION_INFO_V1(falcon_create_slice_table);
+PG_FUNCTION_INFO_V1(falcon_create_kvmeta_table);
 PG_FUNCTION_INFO_V1(falcon_prepare_commands);
 
 Datum falcon_create_distributed_data_table(PG_FUNCTION_ARGS)
@@ -22,6 +24,20 @@ Datum falcon_create_distributed_data_table(PG_FUNCTION_ARGS)
     PG_RETURN_INT16(SUCCESS);
 }
 
+Datum falcon_create_slice_table(PG_FUNCTION_ARGS)
+{
+    FalconCreateSliceTable();
+
+    PG_RETURN_INT16(SUCCESS);
+}
+
+Datum falcon_create_kvmeta_table(PG_FUNCTION_ARGS)
+{
+    FalconCreateKvmetaTable();
+
+    PG_RETURN_INT16(SUCCESS);
+}
+
 Datum falcon_prepare_commands(PG_FUNCTION_ARGS)
 {
     FalconPrepareCommands();
@@ -67,6 +83,74 @@ void FalconCreateDistributedDataTable()
     SPI_finish();
 }
 
+void FalconCreateSliceTable()
+{
+    List *shardTableData = GetShardTableData();
+
+    StringInfo toExecCommand = makeStringInfo();
+    StringInfo name = makeStringInfo();
+    for (int i = 0; i < list_length(shardTableData); ++i) {
+        Form_falcon_shard_table data = list_nth(shardTableData, i);
+        if (data->server_id != GetLocalServerId())
+            continue;
+
+        resetStringInfo(name);
+        appendStringInfo(name, "%s_%d", SliceTableName, data->range_point);
+        if (CheckIfRelationExists(name->data, PG_CATALOG_NAMESPACE))
+            continue;
+        ConstructCreateSliceTableCommand(toExecCommand, name->data);
+    }
+    if (toExecCommand->len == 0)
+        return;
+
+    int spiConnectionResult = SPI_connect();
+    if (spiConnectionResult != SPI_OK_CONNECT) {
+        SPI_finish();
+        FALCON_ELOG_ERROR(PROGRAM_ERROR, "could not connect to SPI manager.");
+    }
+
+    int spiQueryResult = SPI_execute(toExecCommand->data, false, 0);
+    if (spiQueryResult != SPI_OK_UTILITY) {
+        SPI_finish();
+        FALCON_ELOG_ERROR(PROGRAM_ERROR, "spi exec failed.");
+    }
+    SPI_finish();
+}
+
+void FalconCreateKvmetaTable()
+{
+    List *shardTableData = GetShardTableData();
+
+    StringInfo toExecCommand = makeStringInfo();
+    StringInfo name = makeStringInfo();
+    for (int i = 0; i < list_length(shardTableData); ++i) {
+        Form_falcon_shard_table data = list_nth(shardTableData, i);
+        if (data->server_id != GetLocalServerId())
+            continue;
+
+        resetStringInfo(name);
+        appendStringInfo(name, "%s_%d", KvmetaTableName, data->range_point);
+        if (CheckIfRelationExists(name->data, PG_CATALOG_NAMESPACE))
+            continue;
+        ConstructCreateKvmetaTableCommand(toExecCommand, name->data);
+    }
+    if (toExecCommand->len == 0)
+        return;
+
+    int spiConnectionResult = SPI_connect();
+    if (spiConnectionResult != SPI_OK_CONNECT) {
+        SPI_finish();
+        FALCON_ELOG_ERROR(PROGRAM_ERROR, "could not connect to SPI manager.");
+    }
+
+    int spiQueryResult = SPI_execute(toExecCommand->data, false, 0);
+    if (spiQueryResult != SPI_OK_UTILITY) {
+        SPI_finish();
+        FALCON_ELOG_ERROR(PROGRAM_ERROR, "spi exec failed.");
+    }
+    SPI_finish();
+}
+
 void FalconPrepareCommands()
 {
     static bool Prepared = false;
diff --git a/falcon/falcon--1.0.sql b/falcon/falcon--1.0.sql
index 95264fb..e5ebf43 100644
--- a/falcon/falcon--1.0.sql
+++ b/falcon/falcon--1.0.sql
@@ -291,3 +291,50 @@ CREATE FUNCTION pg_catalog.falcon_meta_call_by_serialized_data(type int, count i
     LANGUAGE C STRICT
     AS 'MODULE_PATHNAME', $$falcon_meta_call_by_serialized_data$$;
 COMMENT ON FUNCTION pg_catalog.falcon_meta_call_by_serialized_data(type int, count int, param bytea) IS 'falcon meta call by serialized data';
+
+
+----------------------------------------------------------------
+-- falcon_create_slice_table
+----------------------------------------------------------------
+CREATE FUNCTION pg_catalog.falcon_create_slice_table()
+    RETURNS INTEGER
+    LANGUAGE C STRICT
+    AS 'MODULE_PATHNAME', $$falcon_create_slice_table$$;
+COMMENT ON FUNCTION pg_catalog.falcon_create_slice_table()
+    IS 'falcon build slice table';
+
+
+----------------------------------------------------------------
+-- falcon_create_kvmeta_table
+----------------------------------------------------------------
+CREATE FUNCTION pg_catalog.falcon_create_kvmeta_table()
+    RETURNS INTEGER
+    LANGUAGE C STRICT
+    AS 'MODULE_PATHNAME', $$falcon_create_kvmeta_table$$;
+COMMENT ON FUNCTION pg_catalog.falcon_create_kvmeta_table()
+    IS 'falcon build kvmeta shard table';
+
+
+----------------------------------------------------------------
+-- falcon_kvsliceid_table
+----------------------------------------------------------------]
+CREATE TABLE falcon.falcon_kvsliceid_table(
+    keystr text,
+    slice_id bigint
+);
+CREATE UNIQUE INDEX falcon_kvsliceid_table_index ON falcon.falcon_kvsliceid_table using btree(keystr);
+ALTER TABLE falcon.falcon_kvsliceid_table SET SCHEMA pg_catalog;
+GRANT SELECT ON pg_catalog.falcon_kvsliceid_table TO public;
+
+
+----------------------------------------------------------------
+-- falcon_filesliceid_table
+----------------------------------------------------------------]
+CREATE TABLE falcon.falcon_filesliceid_table(
+    keystr text,
+    slice_id bigint
+);
+CREATE UNIQUE INDEX falcon_filesliceid_table_index ON falcon.falcon_filesliceid_table using btree(keystr);
+ALTER TABLE falcon.falcon_filesliceid_table SET SCHEMA pg_catalog;
+GRANT SELECT ON pg_catalog.falcon_filesliceid_table TO public;
+
diff --git a/falcon/falcon_init.c b/falcon/falcon_init.c
index e310e4a..abe4699 100644
--- a/falcon/falcon_init.c
+++ b/falcon/falcon_init.c
@@ -26,9 +26,14 @@
 #include "utils/path_parse.h"
 #include "utils/rwlock.h"
 #include "utils/shmem_control.h"
+#include "utils/falcon_plugin_guc.h"
+#include "plugin/falcon_plugin_loader.h"
 
 PG_MODULE_MAGIC;
 
+/* Plugin system GUC variables */
+char *falcon_plugin_directory = NULL;
+
 void _PG_init(void);
 static void FalconStart2PCCleanupWorker(void);
 static void FalconStartConnectionPoolWorker(void);
@@ -52,6 +57,10 @@ void _PG_init(void)
 
     FalconStart2PCCleanupWorker();
     FalconStartConnectionPoolWorker();
+
+    if (falcon_plugin_directory) {
+        FalconPluginSystemInit(falcon_plugin_directory);
+    }
 }
 
 /*
@@ -151,6 +160,7 @@ static void FalconShmemRequest(void)
     RequestAddinShmemSpace(ShardTableShmemsize());
     RequestAddinShmemSpace(DirPathShmemsize());
     RequestAddinShmemSpace(FalconConnectionPoolShmemsize());
+    RequestAddinShmemSpace(FalconPluginShmemSize());
 }
 static void FalconShmemInit(void)
 {
@@ -166,8 +176,12 @@ static void FalconShmemInit(void)
     ShardTableShmemInit();
     DirPathShmemInit();
     FalconConnectionPoolShmemInit();
+    FalconPluginShmemInit();
 
     LWLockRelease(AddinShmemInitLock);
+
+
+    FalconPluginInitBackgroundPlugins();
 }
 static void InitializeFalconShmemStruct(void)
 {
@@ -273,4 +287,26 @@ static void RegisterFalconConfigVariables(void)
                             NULL,
                             NULL);
     FalconConnectionPoolShmemSize = (uint64_t)FalconConnectionPoolShmemSizeInMB * 1024 * 1024;
+
+    DefineCustomStringVariable("falcon_plugin.directory",
+                              gettext_noop("Directory containing Falcon plugins."),
+                              NULL,
+                              &falcon_plugin_directory,
+                              NULL,
+                              PGC_POSTMASTER,
+                              0,
+                              NULL,
+                              NULL,
+                              NULL);
+
+    DefineCustomStringVariable("falcon.local_ip",
+                              gettext_noop("Local IP address for Falcon node."),
+                              NULL,
+                              &FalconNodeLocalIp,
+                              FALCON_NODE_LOCAL_IP_DEFAULT,
+                              PGC_POSTMASTER,
+                              0,
+                              NULL,
+                              NULL,
+                              NULL);
 }
diff --git a/falcon/include/connection_pool/connection_pool_config.h b/falcon/include/connection_pool/connection_pool_config.h
index 9637380..9296862 100644
--- a/falcon/include/connection_pool/connection_pool_config.h
+++ b/falcon/include/connection_pool/connection_pool_config.h
@@ -16,6 +16,9 @@ extern int FalconPGPort;
 #define FALCON_CONNECTION_POOL_PORT_DEFAULT 56999
 extern int FalconConnectionPoolPort;
 
+#define FALCON_NODE_LOCAL_IP_DEFAULT "127.0.0.1"
+extern char *FalconNodeLocalIp;
+
 #define FALCON_CONNECTION_POOL_SIZE_DEFAULT 32
 extern int FalconConnectionPoolSize;
 
diff --git a/falcon/include/connection_pool/falcon_meta_service.h b/falcon/include/connection_pool/falcon_meta_service.h
new file mode 100644
index 0000000..3842343
--- /dev/null
+++ b/falcon/include/connection_pool/falcon_meta_service.h
@@ -0,0 +1,145 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#ifndef FALCON_META_SERVICE_H
+#define FALCON_META_SERVICE_H
+
+#include <memory>
+#include <mutex>
+#include <chrono>
+#include "connection_pool/falcon_meta_service_interface.h"
+
+class PGConnection;
+class PGConnectionPool;
+
+namespace falcon {
+namespace meta_service {
+
+/**
+ * Falcon 元数据异步任务
+ * 封装一个 Falcon 元数据操作请求
+ */
+class AsyncFalconMetaServiceJob {
+private:
+    FalconMetaServiceRequest request;
+    FalconMetaServiceResponse response;
+    FalconMetaServiceCallback callback;
+    void* user_context;
+    std::chrono::steady_clock::time_point start_time;  // 请求接收时间
+
+    void CleanupResponseData() {
+        if (response.data != nullptr) {
+            switch (response.opcode) {
+                case DFC_GET_KV_META:
+                    delete static_cast<KvDataResponse*>(response.data);
+                    break;
+                case DFC_PLAIN_COMMAND:
+                    delete static_cast<PlainCommandResponse*>(response.data);
+                    break;
+                case DFC_CREATE:
+                    delete static_cast<CreateResponse*>(response.data);
+                    break;
+                case DFC_OPEN:
+                    delete static_cast<OpenResponse*>(response.data);
+                    break;
+                case DFC_STAT:
+                    delete static_cast<StatResponse*>(response.data);
+                    break;
+                case DFC_UNLINK:
+                    delete static_cast<UnlinkResponse*>(response.data);
+                    break;
+                case DFC_READDIR:
+                    delete static_cast<ReadDirResponse*>(response.data);
+                    break;
+                case DFC_OPENDIR:
+                    delete static_cast<OpenDirResponse*>(response.data);
+                    break;
+                case DFC_RENAME_SUB_RENAME_LOCALLY:
+                    delete static_cast<RenameSubRenameLocallyResponse*>(response.data);
+                    break;
+                case DFC_SLICE_GET:
+                    delete static_cast<SliceInfoResponse*>(response.data);
+                    break;
+                case DFC_FETCH_SLICE_ID:
+                    delete static_cast<SliceIdResponse*>(response.data);
+                    break;
+                default:
+                    // PUT, DELETE, MKDIR, RMDIR, CLOSE, RENAME, UTIMENS, CHOWN, CHMOD, SLICE_PUT, SLICE_DEL 不返回数据
+                    break;
+            }
+            response.data = nullptr;
+        }
+    }
+
+public:
+    AsyncFalconMetaServiceJob(const FalconMetaServiceRequest& req,
+                              FalconMetaServiceCallback cb,
+                              void* ctx)
+        : request(req), callback(cb), user_context(ctx),
+          start_time(std::chrono::steady_clock::now()) {}
+
+    ~AsyncFalconMetaServiceJob() {
+        CleanupResponseData();
+    }
+
+    FalconMetaServiceRequest& GetRequest() { return request; }
+    FalconMetaServiceResponse& GetResponse() { return response; }
+
+    void Done() {
+        auto end_time = std::chrono::steady_clock::now();
+        auto total_us = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time).count();
+
+        printf("[perf][FalconMetaService] opcode=%d(%s), status=%d, total=%ld us\n",
+               response.opcode, FalconMetaOperationTypeName(response.opcode),
+               response.status, total_us);
+        fflush(stdout);
+
+        if (callback) {
+            callback(response, user_context);
+            CleanupResponseData();
+        }
+    }
+};
+
+/**
+ * Falcon 元数据服务实现类
+ * 提供 KV 操作和文件语义操作
+ */
+class FalconMetaService {
+private:
+    std::shared_ptr<PGConnectionPool> pgConnectionPool;
+    static FalconMetaService* instance;
+    static std::mutex instanceMutex;
+    bool initialized;
+
+    FalconMetaService();
+
+public:
+    static FalconMetaService* Instance();
+
+    bool Init(int port, int pool_size = 10);
+
+    bool IsInitialized() const { return initialized; }
+
+    virtual ~FalconMetaService();
+
+    int DispatchFalconMetaServiceJob(AsyncFalconMetaServiceJob* job);
+
+    /**
+     * 提交 Falcon 元数据服务请求（成员方法）
+     *
+     * @param request: Falcon 元数据服务请求
+     * @param callback: 回调函数
+     * @param user_context: 用户上下文指针
+     * @return: 0 表示成功，非0 表示失败
+     */
+    int SubmitFalconMetaRequest(const FalconMetaServiceRequest& request,
+                                FalconMetaServiceCallback callback,
+                                void* user_context = nullptr);
+};
+
+} // namespace meta_service
+} // namespace falcon
+
+#endif // FALCON_META_SERVICE_H
diff --git a/falcon/include/connection_pool/falcon_meta_service_interface.h b/falcon/include/connection_pool/falcon_meta_service_interface.h
new file mode 100644
index 0000000..0d6de49
--- /dev/null
+++ b/falcon/include/connection_pool/falcon_meta_service_interface.h
@@ -0,0 +1,693 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#ifndef FALCON_META_SERVICE_INTERFACE_H
+#define FALCON_META_SERVICE_INTERFACE_H
+
+#include <string>
+#include <vector>
+#include <variant>
+#include <cstdint>
+#include <functional>
+
+namespace falcon {
+namespace meta_service {
+
+/**
+ * 数据切片结构（元数据索引）
+ */
+struct FormDataSlice {
+    uint64_t value_key;      // 全局 key 生成器（唯一数据块 ID）
+    uint64_t location;       // 数据存储位置（偏移或地址）
+    uint32_t size;           // 切片大小（字节）
+
+    FormDataSlice() : value_key(0), location(0), size(0) {}
+    FormDataSlice(uint64_t vk, uint64_t loc, uint32_t sz)
+        : value_key(vk), location(loc), size(sz) {}
+};
+
+/**
+ * KV 索引数据结构
+ * 表示一个完整的 KV 对的元数据索引，value 被切成多个 slice（每个 2MB）
+ */
+struct FormDataKvIndex {
+    std::string key;                        // 用户的 key
+    uint32_t valueLen;                      // 完整 value 的总长度
+    uint16_t sliceNum;                      // 切片数量（2MB 拆分）
+    std::vector<FormDataSlice> dataSlices;  // 所有切片的元数据
+
+    FormDataKvIndex() : valueLen(0), sliceNum(0) {}
+};
+
+/**
+ * Falcon 元数据操作类型
+ * 对应 FlatBuffers 中的操作类型
+ */
+enum FalconMetaOperationType {
+    // KV 语义操作
+    DFC_PUT_KEY_META = 1,              // 插入或更新 KV 元数据
+    DFC_GET_KV_META = 2,               // 查询 KV 元数据
+    DFC_DELETE_KV_META = 3,            // 删除 KV 元数据
+    DFC_PLAIN_COMMAND = 4,             // 查询分片表信息（falcon_renew_shard_table）
+
+    // 文件语义操作 - 基础操作
+    DFC_MKDIR = 5,                     // 创建目录
+    DFC_CREATE = 6,                    // 创建文件
+    DFC_STAT = 7,                      // 查询文件/目录状态
+    DFC_OPEN = 8,                      // 打开文件
+    DFC_CLOSE = 9,                     // 关闭文件
+    DFC_UNLINK = 10,                   // 删除文件
+    DFC_READDIR = 11,                  // 读取目录内容
+    DFC_OPENDIR = 12,                  // 打开目录
+    DFC_RMDIR = 13,                    // 删除目录
+    DFC_RENAME = 14,                   // 重命名文件/目录
+
+    // 文件语义操作 - 子操作
+    DFC_MKDIR_SUB_MKDIR = 15,          // MKDIR 子操作：创建子目录
+    DFC_MKDIR_SUB_CREATE = 16,         // MKDIR 子操作：创建元数据
+    DFC_RMDIR_SUB_RMDIR = 17,          // RMDIR 子操作：删除子目录
+    DFC_RMDIR_SUB_UNLINK = 18,         // RMDIR 子操作：删除文件
+    DFC_RENAME_SUB_RENAME_LOCALLY = 19,// RENAME 子操作：本地重命名
+    DFC_RENAME_SUB_CREATE = 20,        // RENAME 子操作：创建新条目
+
+    // 文件属性操作
+    DFC_UTIMENS = 21,                  // 修改文件时间戳
+    DFC_CHOWN = 22,                    // 修改文件所有者
+    DFC_CHMOD = 23,                    // 修改文件权限
+
+    // Slice 操作
+    DFC_SLICE_PUT = 24,                // 存储 Slice 元数据
+    DFC_SLICE_GET = 25,                // 查询 Slice 元数据
+    DFC_SLICE_DEL = 26,                // 删除 Slice 元数据
+    DFC_FETCH_SLICE_ID = 27,           // 分配 Slice ID
+    NOT_SUPPORTED
+};
+
+/**
+ * 获取 FalconMetaOperationType 的字符串名称
+ */
+inline const char* FalconMetaOperationTypeName(FalconMetaOperationType op) {
+    switch (op) {
+        case DFC_PUT_KEY_META: return "DFC_PUT_KEY_META";
+        case DFC_GET_KV_META: return "DFC_GET_KV_META";
+        case DFC_DELETE_KV_META: return "DFC_DELETE_KV_META";
+        case DFC_PLAIN_COMMAND: return "DFC_PLAIN_COMMAND";
+        case DFC_MKDIR: return "DFC_MKDIR";
+        case DFC_CREATE: return "DFC_CREATE";
+        case DFC_STAT: return "DFC_STAT";
+        case DFC_OPEN: return "DFC_OPEN";
+        case DFC_CLOSE: return "DFC_CLOSE";
+        case DFC_UNLINK: return "DFC_UNLINK";
+        case DFC_READDIR: return "DFC_READDIR";
+        case DFC_OPENDIR: return "DFC_OPENDIR";
+        case DFC_RMDIR: return "DFC_RMDIR";
+        case DFC_RENAME: return "DFC_RENAME";
+        case DFC_MKDIR_SUB_MKDIR: return "DFC_MKDIR_SUB_MKDIR";
+        case DFC_MKDIR_SUB_CREATE: return "DFC_MKDIR_SUB_CREATE";
+        case DFC_RMDIR_SUB_RMDIR: return "DFC_RMDIR_SUB_RMDIR";
+        case DFC_RMDIR_SUB_UNLINK: return "DFC_RMDIR_SUB_UNLINK";
+        case DFC_RENAME_SUB_RENAME_LOCALLY: return "DFC_RENAME_SUB_RENAME_LOCALLY";
+        case DFC_RENAME_SUB_CREATE: return "DFC_RENAME_SUB_CREATE";
+        case DFC_UTIMENS: return "DFC_UTIMENS";
+        case DFC_CHOWN: return "DFC_CHOWN";
+        case DFC_CHMOD: return "DFC_CHMOD";
+        case DFC_SLICE_PUT: return "DFC_SLICE_PUT";
+        case DFC_SLICE_GET: return "DFC_SLICE_GET";
+        case DFC_SLICE_DEL: return "DFC_SLICE_DEL";
+        case DFC_FETCH_SLICE_ID: return "DFC_FETCH_SLICE_ID";
+        case NOT_SUPPORTED: return "NOT_SUPPORTED";
+        default: return "UNKNOWN";
+    }
+}
+
+/**
+ * Shard Table 信息结构（用于 DFC_PLAIN_COMMAND）
+ */
+struct ShardTableInfo {
+    int range_min;     // 哈希范围最小值
+    int range_max;     // 哈希范围最大值
+    std::string host;  // 服务器 IP
+    int port;          // 服务器端口
+    int server_id;     // 服务器 ID
+
+    ShardTableInfo() : range_min(0), range_max(0), port(0), server_id(0) {}
+};
+
+/**
+ * 响应数据结构 - KV GET 操作
+ */
+struct KvDataResponse {
+    FormDataKvIndex kv_data;               // KV 元数据
+
+    KvDataResponse() {}
+};
+
+/**
+ * 响应数据结构 - 通用命令查询（PlainCommand）
+ */
+struct PlainCommandResponse {
+    uint32_t row;                                   // 行数（PQntuples）
+    uint32_t col;                                   // 列数（PQnfields）
+    std::vector<std::string> data;                  // 原始数据（一维数组，按行优先顺序：data[row_idx * col + col_idx]）
+
+    PlainCommandResponse() : row(0), col(0) {}
+};
+
+/**
+ * 通用命令参数（DFC_PLAIN_COMMAND）
+ */
+struct PlainCommandParam {
+    std::string command;
+
+    PlainCommandParam() {}
+    PlainCommandParam(const std::string& cmd) : command(cmd) {}
+};
+
+/**
+ * 仅路径参数（DFC_MKDIR, DFC_CREATE, DFC_STAT, DFC_OPEN, DFC_UNLINK, DFC_OPENDIR, DFC_RMDIR）
+ */
+struct PathOnlyParam {
+    std::string path;
+
+    PathOnlyParam() {}
+    PathOnlyParam(const std::string& p) : path(p) {}
+};
+
+/**
+ * CLOSE 操作参数
+ */
+struct CloseParam {
+    std::string path;
+    int64_t st_size;
+    uint64_t st_mtim;
+    int32_t node_id;
+
+    CloseParam() : st_size(0), st_mtim(0), node_id(0) {}
+};
+
+/**
+ * READDIR 操作参数
+ */
+struct ReadDirParam {
+    std::string path;
+    int32_t max_read_count;
+    int32_t last_shard_index;
+    std::string last_file_name;
+
+    ReadDirParam() : max_read_count(-1), last_shard_index(-1) {}
+};
+
+/**
+ * MKDIR 子操作 - 创建子目录参数
+ */
+struct MkdirSubMkdirParam {
+    uint64_t parent_id;
+    std::string name;
+    uint64_t inode_id;
+
+    MkdirSubMkdirParam() : parent_id(0), inode_id(0) {}
+};
+
+/**
+ * MKDIR 子操作 - 创建元数据参数
+ */
+struct MkdirSubCreateParam {
+    uint64_t parent_id_part_id;
+    std::string name;
+    uint64_t inode_id;
+    uint32_t st_mode;
+    uint64_t st_mtim;
+    int64_t st_size;
+
+    MkdirSubCreateParam() : parent_id_part_id(0), inode_id(0), st_mode(0), st_mtim(0), st_size(0) {}
+};
+
+/**
+ * RMDIR 子操作 - 删除子目录参数
+ */
+struct RmdirSubRmdirParam {
+    uint64_t parent_id;
+    std::string name;
+
+    RmdirSubRmdirParam() : parent_id(0) {}
+};
+
+/**
+ * RMDIR 子操作 - 删除文件参数
+ */
+struct RmdirSubUnlinkParam {
+    uint64_t parent_id_part_id;
+    std::string name;
+
+    RmdirSubUnlinkParam() : parent_id_part_id(0) {}
+};
+
+/**
+ * RENAME 操作参数
+ */
+struct RenameParam {
+    std::string src;
+    std::string dst;
+
+    RenameParam() {}
+    RenameParam(const std::string& s, const std::string& d) : src(s), dst(d) {}
+};
+
+/**
+ * RENAME 子操作 - 本地重命名参数
+ */
+struct RenameSubRenameLocallyParam {
+    uint64_t src_parent_id;
+    uint64_t src_parent_id_part_id;
+    std::string src_name;
+    uint64_t dst_parent_id;
+    uint64_t dst_parent_id_part_id;
+    std::string dst_name;
+    bool target_is_directory;
+    uint64_t directory_inode_id;
+    int32_t src_lock_order;
+
+    RenameSubRenameLocallyParam()
+        : src_parent_id(0), src_parent_id_part_id(0),
+          dst_parent_id(0), dst_parent_id_part_id(0),
+          target_is_directory(false), directory_inode_id(0), src_lock_order(0) {}
+};
+
+/**
+ * RENAME 子操作 - 创建新条目参数
+ */
+struct RenameSubCreateParam {
+    uint64_t parentid_partid;
+    std::string name;
+    uint64_t st_ino;
+    uint64_t st_dev;
+    uint32_t st_mode;
+    uint64_t st_nlink;
+    uint32_t st_uid;
+    uint32_t st_gid;
+    uint64_t st_rdev;
+    int64_t st_size;
+    int64_t st_blksize;
+    int64_t st_blocks;
+    uint64_t st_atim;
+    uint64_t st_mtim;
+    uint64_t st_ctim;
+    int32_t node_id;
+
+    RenameSubCreateParam()
+        : parentid_partid(0), st_ino(0), st_dev(0), st_mode(0), st_nlink(0),
+          st_uid(0), st_gid(0), st_rdev(0), st_size(0), st_blksize(0),
+          st_blocks(0), st_atim(0), st_mtim(0), st_ctim(0), node_id(0) {}
+};
+
+/**
+ * UTIMENS 操作参数
+ */
+struct UtimeNsParam {
+    std::string path;
+    uint64_t st_atim;
+    uint64_t st_mtim;
+
+    UtimeNsParam() : st_atim(0), st_mtim(0) {}
+};
+
+/**
+ * CHOWN 操作参数
+ */
+struct ChownParam {
+    std::string path;
+    uint32_t st_uid;
+    uint32_t st_gid;
+
+    ChownParam() : st_uid(0), st_gid(0) {}
+};
+
+/**
+ * CHMOD 操作参数
+ */
+struct ChmodParam {
+    std::string path;
+    uint64_t st_mode;
+
+    ChmodParam() : st_mode(0) {}
+};
+
+/**
+ * SLICE_GET/SLICE_DEL 操作参数
+ */
+struct SliceIndexParam {
+    std::string filename;
+    uint64_t inodeid;
+    uint32_t chunkid;
+
+    SliceIndexParam() : inodeid(0), chunkid(0) {}
+
+    SliceIndexParam(
+        const std::string& fname,
+        uint64_t inid,
+        uint32_t chid
+    )
+        : filename(fname)
+        , inodeid(inid)
+        , chunkid(chid)
+    {}
+};
+
+/**
+ * SLICE_PUT 操作参数
+ */
+struct SliceInfoParam {
+    std::string filename;
+    uint32_t slicenum;
+    std::vector<uint64_t> inodeid;
+    std::vector<uint32_t> chunkid;
+    std::vector<uint64_t> sliceid;
+    std::vector<uint32_t> slicesize;
+    std::vector<uint32_t> sliceoffset;
+    std::vector<uint32_t> slicelen;
+    std::vector<uint32_t> sliceloc1;
+    std::vector<uint32_t> sliceloc2;
+
+    SliceInfoParam() : slicenum(0) {}
+
+    SliceInfoParam(
+        const std::string& fname,
+        uint32_t snum,
+        const std::vector<uint64_t>& inodes,
+        const std::vector<uint32_t>& chids,
+        const std::vector<uint64_t>& slids,
+        const std::vector<uint32_t>& szs,
+        const std::vector<uint32_t>& offs,
+        const std::vector<uint32_t>& lens,
+        const std::vector<uint32_t>& loc1s,
+        const std::vector<uint32_t>& loc2s
+    )
+        : filename(fname)
+        , slicenum(snum)
+        , inodeid(inodes)
+        , chunkid(chids)
+        , sliceid(slids)
+        , slicesize(szs)
+        , sliceoffset(offs)
+        , slicelen(lens)
+        , sliceloc1(loc1s)
+        , sliceloc2(loc2s)
+    {}
+};
+
+/**
+ * FETCH_SLICE_ID 操作参数
+ */
+struct SliceIdParam {
+    uint32_t count;
+    uint8_t type;
+
+    SliceIdParam() : count(0), type(0) {}
+
+    SliceIdParam(uint32_t cnt, uint8_t tp)
+        : count(cnt), type(tp)
+    {}
+};
+
+struct EmptyParam {};
+
+using AnyMetaParam = std::variant<
+    EmptyParam,
+    PlainCommandParam,
+    PathOnlyParam,
+    CloseParam,
+    ReadDirParam,
+    MkdirSubMkdirParam,
+    MkdirSubCreateParam,
+    RmdirSubRmdirParam,
+    RmdirSubUnlinkParam,
+    RenameParam,
+    RenameSubRenameLocallyParam,
+    RenameSubCreateParam,
+    UtimeNsParam,
+    ChownParam,
+    ChmodParam,
+    SliceIndexParam,
+    SliceInfoParam
+>;
+
+namespace meta_param_helper {
+
+template<typename T>
+inline T* Get(AnyMetaParam& param) {
+    if (std::holds_alternative<T>(param)) {
+        return &std::get<T>(param);
+    }
+    return nullptr;
+}
+
+template<typename T>
+inline const T* Get(const AnyMetaParam& param) {
+    if (std::holds_alternative<T>(param)) {
+        return &std::get<T>(param);
+    }
+    return nullptr;
+}
+
+template<typename T>
+inline void Set(AnyMetaParam& param, const T& value) {
+    param = value;
+}
+
+template<typename T>
+inline void Set(AnyMetaParam& param, T&& value) {
+    param = std::move(value);
+}
+
+} // namespace meta_param_helper
+
+/**
+ * 响应数据结构 - 文件创建（CREATE）
+ */
+struct CreateResponse {
+    uint64_t st_ino;
+    int64_t node_id;
+    uint64_t st_dev;
+    uint32_t st_mode;
+    uint64_t st_nlink;
+    uint32_t st_uid;
+    uint32_t st_gid;
+    uint64_t st_rdev;
+    int64_t st_size;
+    int64_t st_blksize;
+    int64_t st_blocks;
+    uint64_t st_atim;
+    uint64_t st_mtim;
+    uint64_t st_ctim;
+
+    CreateResponse()
+        : st_ino(0), node_id(0), st_dev(0), st_mode(0), st_nlink(0),
+          st_uid(0), st_gid(0), st_rdev(0), st_size(0), st_blksize(0),
+          st_blocks(0), st_atim(0), st_mtim(0), st_ctim(0) {}
+};
+
+/**
+ * 响应数据结构 - 文件打开（OPEN）
+ */
+struct OpenResponse {
+    uint64_t st_ino;
+    int64_t node_id;
+    uint64_t st_dev;
+    uint32_t st_mode;
+    uint64_t st_nlink;
+    uint32_t st_uid;
+    uint32_t st_gid;
+    uint64_t st_rdev;
+    int64_t st_size;
+    int64_t st_blksize;
+    int64_t st_blocks;
+    uint64_t st_atim;
+    uint64_t st_mtim;
+    uint64_t st_ctim;
+
+    OpenResponse()
+        : st_ino(0), node_id(0), st_dev(0), st_mode(0), st_nlink(0),
+          st_uid(0), st_gid(0), st_rdev(0), st_size(0), st_blksize(0),
+          st_blocks(0), st_atim(0), st_mtim(0), st_ctim(0) {}
+};
+
+/**
+ * 响应数据结构 - 文件状态（STAT）
+ */
+struct StatResponse {
+    uint64_t st_ino;
+    uint64_t st_dev;
+    uint32_t st_mode;
+    uint64_t st_nlink;
+    uint32_t st_uid;
+    uint32_t st_gid;
+    uint64_t st_rdev;
+    int64_t st_size;
+    int64_t st_blksize;
+    int64_t st_blocks;
+    uint64_t st_atim;
+    uint64_t st_mtim;
+    uint64_t st_ctim;
+
+    StatResponse()
+        : st_ino(0), st_dev(0), st_mode(0), st_nlink(0),
+          st_uid(0), st_gid(0), st_rdev(0), st_size(0), st_blksize(0),
+          st_blocks(0), st_atim(0), st_mtim(0), st_ctim(0) {}
+};
+
+/**
+ * 响应数据结构 - 文件删除（UNLINK）
+ */
+struct UnlinkResponse {
+    uint64_t st_ino;
+    int64_t st_size;
+    int64_t node_id;
+
+    UnlinkResponse() : st_ino(0), st_size(0), node_id(0) {}
+};
+
+/**
+ * 单个目录项
+ */
+struct OneReadDirResponse {
+    std::string file_name;
+    uint32_t st_mode;
+
+    OneReadDirResponse() : st_mode(0) {}
+};
+
+/**
+ * 响应数据结构 - 目录读取（READDIR）
+ */
+struct ReadDirResponse {
+    int32_t last_shard_index;
+    std::string last_file_name;
+    std::vector<OneReadDirResponse> result_list;
+
+    ReadDirResponse() : last_shard_index(0) {}
+};
+
+/**
+ * 响应数据结构 - 打开目录（OPENDIR）
+ */
+struct OpenDirResponse {
+    uint64_t st_ino;
+
+    OpenDirResponse() : st_ino(0) {}
+};
+
+/**
+ * 响应数据结构 - 重命名本地操作
+ */
+struct RenameSubRenameLocallyResponse {
+    uint64_t st_ino;
+    uint64_t st_dev;
+    uint32_t st_mode;
+    uint64_t st_nlink;
+    uint32_t st_uid;
+    uint32_t st_gid;
+    uint64_t st_rdev;
+    int64_t st_size;
+    int64_t st_blksize;
+    int64_t st_blocks;
+    uint64_t st_atim;
+    uint64_t st_mtim;
+    uint64_t st_ctim;
+    int32_t node_id;
+
+    RenameSubRenameLocallyResponse()
+        : st_ino(0), st_dev(0), st_mode(0), st_nlink(0),
+          st_uid(0), st_gid(0), st_rdev(0), st_size(0), st_blksize(0),
+          st_blocks(0), st_atim(0), st_mtim(0), st_ctim(0), node_id(0) {}
+};
+
+/**
+ * 响应数据结构 - SLICE_GET 操作
+ */
+struct SliceInfoResponse {
+    uint32_t slicenum;
+    std::vector<uint64_t> inodeid;
+    std::vector<uint32_t> chunkid;
+    std::vector<uint64_t> sliceid;
+    std::vector<uint32_t> slicesize;
+    std::vector<uint32_t> sliceoffset;
+    std::vector<uint32_t> slicelen;
+    std::vector<uint32_t> sliceloc1;
+    std::vector<uint32_t> sliceloc2;
+
+    SliceInfoResponse() : slicenum(0) {}
+
+    SliceInfoResponse(
+        uint32_t snum,
+        const std::vector<uint64_t>& inodes,
+        const std::vector<uint32_t>& chids,
+        const std::vector<uint64_t>& slids,
+        const std::vector<uint32_t>& szs,
+        const std::vector<uint32_t>& offs,
+        const std::vector<uint32_t>& lens,
+        const std::vector<uint32_t>& loc1s,
+        const std::vector<uint32_t>& loc2s
+    )
+        : slicenum(snum)
+        , inodeid(inodes)
+        , chunkid(chids)
+        , sliceid(slids)
+        , slicesize(szs)
+        , sliceoffset(offs)
+        , slicelen(lens)
+        , sliceloc1(loc1s)
+        , sliceloc2(loc2s)
+    {}
+};
+
+/**
+ * 响应数据结构 - FETCH_SLICE_ID 操作
+ */
+struct SliceIdResponse {
+    uint64_t start;
+    uint64_t end;
+
+    SliceIdResponse() : start(0), end(0) {}
+
+    SliceIdResponse(uint64_t s, uint64_t e)
+        : start(s), end(e)
+    {}
+};
+
+/**
+ * Falcon 元数据服务响应结构
+ */
+struct FalconMetaServiceResponse {
+    int status;                       // 0: 成功, 非0: 错误码
+    FalconMetaOperationType opcode;   // 操作码
+    void* data;                       // 返回数据指针（不同操作码对应不同数据结构）
+
+    FalconMetaServiceResponse() : status(0), opcode(DFC_PUT_KEY_META), data(nullptr) {}
+
+    ~FalconMetaServiceResponse() {}
+};
+
+/**
+ * 回调函数类型
+ * 用于异步操作完成后的通知
+ *
+ * @param response: 操作结果
+ * @param user_context: 用户传入的上下文指针
+ */
+using FalconMetaServiceCallback = std::function<void(const FalconMetaServiceResponse&, void*)>;
+
+struct FalconMetaServiceRequest {
+    FalconMetaOperationType operation;
+    FormDataKvIndex kv_data;
+    AnyMetaParam file_params;
+    SliceIdParam sliceid_param;
+
+    FalconMetaServiceRequest()
+        : operation(DFC_PUT_KEY_META) {}
+};
+
+} // namespace meta_service
+} // namespace falcon
+
+#endif // FALCON_META_SERVICE_INTERFACE_H
diff --git a/falcon/include/connection_pool/falcon_meta_service_internal.h b/falcon/include/connection_pool/falcon_meta_service_internal.h
new file mode 100644
index 0000000..12fe663
--- /dev/null
+++ b/falcon/include/connection_pool/falcon_meta_service_internal.h
@@ -0,0 +1,65 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#ifndef FALCON_META_SERVICE_INTERNAL_H
+#define FALCON_META_SERVICE_INTERNAL_H
+
+#include "connection_pool/falcon_meta_service.h"
+#include <brpc/controller.h>
+#include "falcon_meta_rpc.pb.h"
+
+extern "C" {
+#include "remote_connection_utils/error_code_def.h"
+}
+
+namespace falcon {
+namespace meta_service {
+
+constexpr size_t FALCON_MAX_NAME_LENGTH = 255;
+
+/**
+ * Falcon 元数据服务序列化工具类
+ *
+ * 提供 FlatBuffers 格式的序列化/反序列化功能
+ * 使用 SerializedData 封装 FlatBuffers 数据
+ */
+class FalconMetaServiceSerializer {
+public:
+    /**
+     * 将 Falcon 元数据请求序列化为 FlatBuffers 格式
+     *
+     * @param request: Falcon 元数据服务请求
+     * @param proto_request: Protobuf 请求对象（用于传递 type 和 format 等元信息）
+     * @param attachment: BRPC 附件（输出 SerializedData 封装的 FlatBuffers 数据）
+     * @return: SUCCESS 表示成功，其他错误码表示失败原因
+     *
+     * 请求格式规范 (SerializedData):
+     * [size: 4字节] + [FlatBuffers数据: 对齐后的字节]
+     */
+    static FalconErrorCode SerializeRequestToFlatBuffers(
+        const FalconMetaServiceRequest& request,
+        falcon::meta_proto::MetaRequest* proto_request,
+        butil::IOBuf* attachment);
+
+    /**
+     * 从 FlatBuffers 格式反序列化 Falcon 元数据响应
+     *
+     * @param attachment: BRPC 附件（包含 SerializedData 封装的 FlatBuffers 响应数据）
+     * @param response: Falcon 元数据服务响应（输出）
+     * @param operation: 操作类型
+     * @return: true 表示成功，false 表示失败
+     *
+     * FlatBuffers 响应格式 (SerializedData):
+     * [size: 4 bytes] + [FlatBuffers MetaResponse: aligned bytes]
+     */
+    static bool DeserializeResponseFromFlatBuffers(
+        const butil::IOBuf& attachment,
+        FalconMetaServiceResponse* response,
+        FalconMetaOperationType operation);
+};
+
+} // namespace meta_service
+} // namespace falcon
+
+#endif // FALCON_META_SERVICE_INTERNAL_H
diff --git a/falcon/include/connection_pool/task.h b/falcon/include/connection_pool/task.h
index 059f4d2..8b50f0d 100644
--- a/falcon/include/connection_pool/task.h
+++ b/falcon/include/connection_pool/task.h
@@ -7,6 +7,7 @@
 
 #include <brpc/server.h>
 #include <vector>
+#include <chrono>
 #include "falcon_meta_rpc.pb.h"
 #include "concurrentqueue/concurrentqueue.h"
 
@@ -21,6 +22,14 @@ class AsyncMetaServiceJob {
     google::protobuf::Closure *done;
 
   public:
+    // 性能统计时间点
+    std::chrono::steady_clock::time_point create_time;      // 创建时间
+    std::chrono::steady_clock::time_point dequeue_time;     // 出队时间（开始处理）
+    std::chrono::steady_clock::time_point shmem_done_time;  // 共享内存复制完成
+    std::chrono::steady_clock::time_point pg_send_time;     // 发送SQL时间
+    std::chrono::steady_clock::time_point pg_result_time;   // 收到SQL结果时间
+    std::chrono::steady_clock::time_point process_done_time; // 结果处理完成
+
     AsyncMetaServiceJob(brpc::Controller *cntl,
                         const MetaRequest *request,
                         Empty *response,
@@ -28,7 +37,8 @@ class AsyncMetaServiceJob {
         : cntl(cntl),
           request(request),
           response(response),
-          done(done)
+          done(done),
+          create_time(std::chrono::steady_clock::now())
     {
     }
     brpc::Controller *GetCntl() { return cntl; }
diff --git a/falcon/include/distributed_backend/distributed_backend_falcon.h b/falcon/include/distributed_backend/distributed_backend_falcon.h
index d69c64e..5e5a202 100644
--- a/falcon/include/distributed_backend/distributed_backend_falcon.h
+++ b/falcon/include/distributed_backend/distributed_backend_falcon.h
@@ -10,6 +10,8 @@
 #include "metadb/metadata.h"
 
 void FalconCreateDistributedDataTable(void);
+void FalconCreateSliceTable(void);
+void FalconCreateKvmetaTable(void);
 void FalconPrepareCommands(void);
 
 #endif
diff --git a/falcon/include/metadb/kvmeta_table.h b/falcon/include/metadb/kvmeta_table.h
new file mode 100644
index 0000000..132801b
--- /dev/null
+++ b/falcon/include/metadb/kvmeta_table.h
@@ -0,0 +1,28 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#ifndef FALCON_KVMETA_TABLE_H
+#define FALCON_KVMETA_TABLE_H
+
+#include "metadb/metadata.h"
+#include "utils/error_code.h"
+
+#define Natts_falcon_kvmeta_table 6
+#define Anum_falcon_kvmeta_table_userkey 1
+#define Anum_falcon_kvmeta_table_valuelen 2
+#define Anum_falcon_kvmeta_table_slicenum 3
+#define Anum_falcon_kvmeta_table_valuekey 4
+#define Anum_falcon_kvmeta_table_location 5
+#define Anum_falcon_kvmeta_table_slicelen 6
+
+typedef enum FalconKvmetaTableScankeyType {
+    KVMETA_TABLE_USERKEY_EQ,
+    LAST_FALCON_KVMETA_TABLE_SCANKEY_TYPE
+} FalconKvmetaTableScankeyType;
+
+extern const char *KvmetaTableName;
+
+void ConstructCreateKvmetaTableCommand(StringInfo command, const char *name);
+
+#endif
\ No newline at end of file
diff --git a/falcon/include/metadb/meta_handle.h b/falcon/include/metadb/meta_handle.h
index 08743ab..e31989a 100644
--- a/falcon/include/metadb/meta_handle.h
+++ b/falcon/include/metadb/meta_handle.h
@@ -34,6 +34,13 @@ typedef enum FalconSupportMetaService {
     UTIMENS,
     CHOWN,
     CHMOD,
+    KV_PUT,
+    KV_GET,
+    KV_DEL,
+    SLICE_PUT,
+    SLICE_GET,
+    SLICE_DEL,
+    FETCH_SLICE_ID,
     NOT_SUPPORTED
 } FalconSupportMetaService;
 
@@ -58,4 +65,14 @@ void FalconUtimeNsHandle(MetaProcessInfo info);
 void FalconChownHandle(MetaProcessInfo info);
 void FalconChmodHandle(MetaProcessInfo info);
 
+void FalconSlicePutHandle(SliceProcessInfo *infoArray, int count);
+void FalconSliceGetHandle(SliceProcessInfo *infoArray, int count);
+void FalconSliceDelHandle(SliceProcessInfo *infoArray, int count);
+
+void FalconKvmetaPutHandle(KvMetaProcessInfo info);
+void FalconKvmetaGetHandle(KvMetaProcessInfo info);
+void FalconKvmetaDelHandle(KvMetaProcessInfo info);
+
+void FalconFetchSliceIdHandle(SliceIdProcessInfo infoData);
+
 #endif
diff --git a/falcon/include/metadb/meta_process_info.h b/falcon/include/metadb/meta_process_info.h
index 567841e..f621524 100644
--- a/falcon/include/metadb/meta_process_info.h
+++ b/falcon/include/metadb/meta_process_info.h
@@ -61,6 +61,61 @@ typedef struct MetaProcessInfoData
 } MetaProcessInfoData;
 typedef MetaProcessInfoData *MetaProcessInfo;
 
+typedef struct SliceInfo
+{
+    uint64_t inodeId;
+    uint32_t chunkId;
+    uint64_t sliceId;
+    uint32_t sliceSize;
+    uint32_t sliceOffset;
+    uint32_t sliceLen;
+    uint32_t sliceLoc1;
+    uint32_t sliceLoc2;
+} SliceInfo;
+
+typedef struct SliceProcessInfoData
+{
+    uint64_t *inodeIds;
+    uint32_t *chunkIds;
+    uint64_t *sliceIds;
+    uint32_t *sliceSizes;
+    uint32_t *sliceOffsets;
+    uint32_t *sliceLens;
+    uint32_t *sliceLoc1s;
+    uint32_t *sliceloc2s;
+    const char *name;
+    uint64_t inputInodeid;
+    uint32_t inputChunkid;
+    uint32_t count;
+    FalconErrorCode errorCode;
+} SliceProcessInfoData;
+
+typedef SliceProcessInfoData *SliceProcessInfo;
+
+typedef struct KvMetaProcessInfoData
+{
+    const char *userkey;
+    uint32_t valuelen;
+    uint16_t slicenum;
+    uint64_t *valuekey;
+    uint64_t *location;
+    uint32_t *slicelen;
+    FalconErrorCode errorCode;
+} KvMetaProcessInfoData;
+
+typedef KvMetaProcessInfoData *KvMetaProcessInfo;
+
+typedef struct SliceIdProcessInfoData
+{
+    uint32_t count;
+    uint8_t type;
+    uint64_t start;
+    uint64_t end;
+    FalconErrorCode errorCode;
+} SliceIdProcessInfoData;
+
+typedef SliceIdProcessInfoData *SliceIdProcessInfo;
+
 int pg_qsort_meta_process_info_by_path_cmp(const void *a, const void *b);
 
 #endif
diff --git a/falcon/include/metadb/meta_serialize_interface_helper.h b/falcon/include/metadb/meta_serialize_interface_helper.h
index 381f900..54318f3 100644
--- a/falcon/include/metadb/meta_serialize_interface_helper.h
+++ b/falcon/include/metadb/meta_serialize_interface_helper.h
@@ -37,6 +37,28 @@ bool SerializedDataMetaResponseEncodeWithPerProcessFlatBufferBuilder(FalconSuppo
                                                                      MetaProcessInfoData *infoArray,
                                                                      SerializedData *response);
 
+bool SerializedKvMetaParamDecode(FalconSupportMetaService metaService,
+                                 SerializedData *param,
+                                 KvMetaProcessInfo infoData);
+
+bool SerializedKvMetaResponseEncodeWithPerProcessFlatBufferBuilder(FalconSupportMetaService metaService,
+                                                                   KvMetaProcessInfo infoData,
+                                                                   SerializedData *response);
+
+bool SerializedSliceParamDecode(FalconSupportMetaService metaService,
+                                int count,
+                                SerializedData *param,
+                                SliceProcessInfoData *infoArray);
+
+bool SerializedSliceResponseEncodeWithPerProcessFlatBufferBuilder(FalconSupportMetaService metaService,
+                                                                  int count,
+                                                                  SliceProcessInfoData *infoArray,
+                                                                  SerializedData *response);
+
+bool SerializedSliceIdParamDecode(SerializedData *param, SliceIdProcessInfo infoData);
+
+bool SerializedSliceIdResponseEncodeWithPerProcessFlatBufferBuilder(SliceIdProcessInfo infoData, SerializedData *response);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/falcon/include/metadb/slice_table.h b/falcon/include/metadb/slice_table.h
new file mode 100644
index 0000000..d05b4f4
--- /dev/null
+++ b/falcon/include/metadb/slice_table.h
@@ -0,0 +1,31 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#ifndef FALCON_SLICE_TABLE_H
+#define FALCON_SLICE_TABLE_H
+
+#include "metadb/metadata.h"
+#include "utils/error_code.h"
+
+#define Natts_falcon_slice_table 8
+#define Anum_falcon_slice_table_inodeid 1
+#define Anum_falcon_slice_table_chunkid 2
+#define Anum_falcon_slice_table_sliceid 3
+#define Anum_falcon_slice_table_slicesize 4
+#define Anum_falcon_slice_table_sliceoffset 5
+#define Anum_falcon_slice_table_slicelen 6
+#define Anum_falcon_slice_table_sliceloc1 7
+#define Anum_falcon_slice_table_sliceloc2 8
+
+typedef enum FalconSliceTableScankeyType {
+    SLICE_TABLE_INODEID_EQ,
+    SLICE_TABLE_CHUNKID_EQ,
+    LAST_FALCON_SLICE_TABLE_SCANKEY_TYPE
+} FalconSliceTableScankeyType;
+
+extern const char *SliceTableName;
+
+void ConstructCreateSliceTableCommand(StringInfo command, const char *name);
+
+#endif
\ No newline at end of file
diff --git a/falcon/include/metadb/sliceid_table.h b/falcon/include/metadb/sliceid_table.h
new file mode 100644
index 0000000..9474355
--- /dev/null
+++ b/falcon/include/metadb/sliceid_table.h
@@ -0,0 +1,23 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#ifndef FALCON_SLICEID_TABLE_H
+#define FALCON_SLICEID_TABLE_H
+
+#include "metadb/metadata.h"
+#include "utils/error_code.h"
+
+#define Natts_falcon_sliceid_table 2
+#define Anum_falcon_sliceid_table_keystr 1
+#define Anum_falcon_sliceid_table_sliceid 2
+
+typedef enum FalconSliceIdTableScankeyType {
+    SLICEID_TABLE_SLICEID_EQ,
+    LAST_FALCON_SLICEID_TABLE_SCANKEY_TYPE
+} FalconSliceIdTableScankeyType;
+
+Oid KvSliceIdRelationId(void);
+Oid FileSliceIdRelationId(void);
+
+#endif
\ No newline at end of file
diff --git a/falcon/include/plugin/falcon_plugin_framework.h b/falcon/include/plugin/falcon_plugin_framework.h
new file mode 100644
index 0000000..8ebcc9c
--- /dev/null
+++ b/falcon/include/plugin/falcon_plugin_framework.h
@@ -0,0 +1,71 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#ifndef FALCON_PLUGIN_FRAMEWORK_H
+#define FALCON_PLUGIN_FRAMEWORK_H
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <unistd.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define FALCON_PLUGIN_INIT_FUNC_NAME          "plugin_init"
+#define FALCON_PLUGIN_WORK_FUNC_NAME          "plugin_work"
+#define FALCON_PLUGIN_GET_TYPE_FUNC_NAME      "plugin_get_type"
+#define FALCON_PLUGIN_CLEANUP_FUNC_NAME       "plugin_cleanup"
+
+#define FALCON_PLUGIN_MAX_CONFIG_SIZE     4096
+#define FALCON_PLUGIN_MAX_NAME_SIZE       256
+#define FALCON_PLUGIN_MAX_PATH_SIZE       1024
+#define FALCON_PLUGIN_BUFFER_SIZE         1024
+#define FALCON_PLUGIN_MAX_PLUGINS         100
+
+typedef enum {
+    FALCON_PLUGIN_TYPE_INLINE = 0,
+    FALCON_PLUGIN_TYPE_BACKGROUND = 1
+} FalconPluginWorkType;
+
+/* 节点信息结构体 - 供插件使用 */
+typedef struct FalconNodeInfo {
+    char node_ip[16];       /* IPv4 地址 */
+    int node_port;          /* PostgreSQL 端口 */
+    int pooler_port;        /* 连接池端口 */
+} FalconNodeInfo;
+
+typedef struct FalconPluginData {
+    char plugin_name[FALCON_PLUGIN_MAX_NAME_SIZE];
+    char plugin_path[FALCON_PLUGIN_MAX_PATH_SIZE];
+    pid_t main_pid;
+    bool in_use;
+
+    union {
+        char raw_buffer[FALCON_PLUGIN_BUFFER_SIZE];
+    } plugin_data;
+} FalconPluginData;
+
+typedef struct FalconPluginSharedMemory {
+    int num_slots;
+    FalconPluginData plugins[FALCON_PLUGIN_MAX_PLUGINS];
+} FalconPluginSharedMemory;
+
+typedef int (*falcon_plugin_init_func_t)(FalconPluginData *data);
+typedef int (*falcon_plugin_work_func_t)(FalconPluginData *data);
+typedef FalconPluginWorkType (*falcon_plugin_get_type_func_t)(void);
+typedef void (*falcon_plugin_cleanup_func_t)(FalconPluginData *data);
+
+/*
+ * Get current node information
+ * Can be called by plugins to retrieve node configuration
+ * @param node_info: Pointer to FalconNodeInfo structure to fill
+ */
+void FalconPluginGetNodeInfo(FalconNodeInfo *node_info);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FALCON_PLUGIN_FRAMEWORK_H */
diff --git a/falcon/include/plugin/falcon_plugin_loader.h b/falcon/include/plugin/falcon_plugin_loader.h
new file mode 100644
index 0000000..9a22e2b
--- /dev/null
+++ b/falcon/include/plugin/falcon_plugin_loader.h
@@ -0,0 +1,54 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#ifndef FALCON_PLUGIN_LOADER_H
+#define FALCON_PLUGIN_LOADER_H
+
+#include "plugin/falcon_plugin_framework.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Initialize plugin system and register background plugins
+ * Must be called during _PG_init() phase
+ *
+ * @param plugin_dir: Plugin directory path
+ * @return: 0 on success, negative on error
+ *
+ * This function will:
+ * 1. Register BACKGROUND plugins immediately (during _PG_init)
+ * 2. Setup a hook to automatically execute INLINE plugins after shmem init
+ */
+int FalconPluginSystemInit(const char *plugin_dir);
+
+/*
+ * Background worker main function
+ * Called by PostgreSQL background worker system
+ * @param main_arg: PostgreSQL Datum argument (only defined in PostgreSQL context)
+ */
+#ifdef POSTGRES_H
+void FalconPluginBackgroundWorkerMain(Datum main_arg);
+
+/*
+ * Shared memory size calculation
+ * Returns the size needed for plugin shared memory
+ */
+Size FalconPluginShmemSize(void);
+
+/*
+ * Initialize plugin shared memory
+ * Called during PostgreSQL shared memory initialization
+ */
+void FalconPluginShmemInit(void);
+
+void FalconPluginInitBackgroundPlugins(void);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FALCON_PLUGIN_LOADER_H */
diff --git a/falcon/include/utils/falcon_plugin_guc.h b/falcon/include/utils/falcon_plugin_guc.h
new file mode 100644
index 0000000..5de878d
--- /dev/null
+++ b/falcon/include/utils/falcon_plugin_guc.h
@@ -0,0 +1,19 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#ifndef FALCON_PLUGIN_GUC_H
+#define FALCON_PLUGIN_GUC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Plugin system GUC variables */
+extern char *falcon_plugin_directory;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FALCON_PLUGIN_GUC_H */
\ No newline at end of file
diff --git a/falcon/include/utils/utils.h b/falcon/include/utils/utils.h
index 023e404..f6fafe2 100644
--- a/falcon/include/utils/utils.h
+++ b/falcon/include/utils/utils.h
@@ -23,6 +23,9 @@
 #include "metadb/inode_table.h"
 #include "metadb/shard_table.h"
 #include "metadb/xattr_table.h"
+#include "metadb/slice_table.h"
+#include "metadb/kvmeta_table.h"
+#include "metadb/sliceid_table.h"
 
 #define INT32_PRINT_SYMBOL "%d"
 #define UINT32_PRINT_SYMBOL "%u"
@@ -48,6 +51,8 @@ typedef enum CachedRelationType {
     CACHED_RELATION_DIRECTORY_TABLE_INDEX,
     CACHED_RELATION_DISTRIBUTED_TRANSACTION_TABLE,
     CACHED_RELATION_DISTRIBUTED_TRANSACTION_TABLE_INDEX,
+    CACHED_RELATION_KVSLICEID_TABLE,
+    CACHED_RELATION_FILESLICEID_TABLE,
     LAST_CACHED_RELATION_TYPE
 } CachedRelationType;
 extern Oid CachedRelationOid[LAST_CACHED_RELATION_TYPE];
@@ -63,6 +68,9 @@ extern ScanKeyData InodeTableScanKey[LAST_FALCON_INODE_TABLE_SCANKEY_TYPE];
 extern ScanKeyData
     InodeTableIndexParentIdPartIdNameScanKey[LAST_FALCON_INODE_TABLE_INDEX_PARENT_ID_PART_ID_NAME_SCANKEY_TYPE];
 extern ScanKeyData XattrTableScanKey[LAST_FALCON_XATTR_TABLE_SCANKEY_TYPE];
+extern ScanKeyData SliceTableScanKey[LAST_FALCON_SLICE_TABLE_SCANKEY_TYPE];
+extern ScanKeyData KvmetaTableScanKey[LAST_FALCON_KVMETA_TABLE_SCANKEY_TYPE];
+extern ScanKeyData SliceIdTableScanKey[LAST_FALCON_SLICEID_TABLE_SCANKEY_TYPE];
 
 bool ArrayTypeArrayToDatumArrayAndSize(ArrayType *arrayObject, Datum **datumArray, int *datumArrayLength);
 
diff --git a/falcon/metadb/kvmeta_table.c b/falcon/metadb/kvmeta_table.c
new file mode 100644
index 0000000..11fc3ef
--- /dev/null
+++ b/falcon/metadb/kvmeta_table.c
@@ -0,0 +1,30 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#include "metadb/kvmeta_table.h"
+
+
+const char *KvmetaTableName = "falcon_kvmeta_table";
+
+void ConstructCreateKvmetaTableCommand(StringInfo command, const char *name)
+{
+    appendStringInfo(command,
+                     "CREATE TABLE falcon.%s("
+                     "user_key  text,"
+                     "value_len int,"
+                     "slice_num smallint,"
+                     "value_key bigint[],"
+                     "location  bigint[],"
+                     "slice_len int[]);"
+                     "CREATE UNIQUE INDEX %s_index ON falcon.%s USING btree(user_key);"
+                     "ALTER TABLE falcon.%s SET SCHEMA pg_catalog;"
+                     "GRANT SELECT ON pg_catalog.%s TO public;"
+                     "ALTER EXTENSION falcon ADD TABLE %s;",
+                     name,
+                     name,
+                     name,
+                     name,
+                     name,
+                     name);
+}
\ No newline at end of file
diff --git a/falcon/metadb/meta_handle.c b/falcon/metadb/meta_handle.c
index 4f07edc..2e8e0f4 100644
--- a/falcon/metadb/meta_handle.c
+++ b/falcon/metadb/meta_handle.c
@@ -107,6 +107,7 @@ void FalconMkdirHandle(MetaProcessInfo *infoArray, int count)
         info->errorCode = SUCCESS;
         info->errorMsg = NULL;
 
+
         int32_t property;
         FalconErrorCode errorCode =
             VerifyPathValidity(info->path, VERIFY_PATH_VALIDITY_REQUIREMENT_MUST_BE_DIRECTORY, &property);
@@ -359,7 +360,7 @@ void FalconMkdirSubCreateHandle(MetaProcessInfo *infoArray, int count)
                                  info->name,
                                  0,
                                  info->st_mode,
-                                 1,
+                                 2,
                                  0,
                                  0,
                                  0,
@@ -426,8 +427,10 @@ void FalconCreateHandle(MetaProcessInfo *infoArray, int count, bool updateExiste
         info->parentId_partId = CombineParentIdWithPartId(info->parentId, partId);
         info->st_mode = S_IFREG | 0644;
         info->st_mtim = GetCurrentTimestamp();
+        info->st_atim = info->st_mtim;
+        info->st_ctim = info->st_mtim;
         info->st_size = 0;
-        info->node_id = -1;
+        info->node_id = GetLocalServerId();
         info->st_nlink = 1;
         info->etag = (char *)"";
         info->st_dev = 0;
@@ -436,8 +439,6 @@ void FalconCreateHandle(MetaProcessInfo *infoArray, int count, bool updateExiste
         info->st_rdev = 0;
         info->st_blksize = 0;
         info->st_blocks = 0;
-        info->st_atim = 0;
-        info->st_ctim = 0;
 
         int shardId, workerId;
         SearchShardInfoByShardValue(info->parentId_partId, &shardId, &workerId);
@@ -527,12 +528,12 @@ void FalconCreateHandle(MetaProcessInfo *infoArray, int count, bool updateExiste
                                          info->st_size,
                                          0,
                                          0,
+                                         info->st_atim,
                                          info->st_mtim,
-                                         info->st_mtim,
-                                         info->st_mtim,
+                                         info->st_ctim,
                                          info->etag,
                                          0,
-                                         -1,
+                                         info->node_id,
                                          -1);
                     --currentGroupHandled;
                 }
@@ -588,7 +589,7 @@ void FalconStatHandle(MetaProcessInfo *infoArray, int count)
         //
         info->errorCode = SUCCESS;
         info->errorMsg = NULL;
-
+        
         int32_t property;
         //
         FalconErrorCode errorCode = VerifyPathValidity(info->path, 0, &property);
@@ -645,6 +646,9 @@ void FalconStatHandle(MetaProcessInfo *infoArray, int count)
         for (int i = 0; i < list_length(entry->info); ++i) {
             MetaProcessInfo info = list_nth(entry->info, i);
 
+            elog(LOG, "[DEBUG] FalconStatHandle query: shardId=%d, parentId_partId=%lu, name=%s, name_len=%zu",
+                 entry->shardId, info->parentId_partId, info->name, strlen(info->name));
+
             ScanKeyData scanKey[2];
             int scanKeyCount = 2;
             SysScanDesc scanDescriptor = NULL;
@@ -665,6 +669,7 @@ void FalconStatHandle(MetaProcessInfo *infoArray, int count)
             TupleDesc tupleDesc = RelationGetDescr(workerInodeRel);
             if (!HeapTupleIsValid(heapTuple)) {
                 info->errorCode = FILE_NOT_EXISTS;
+                elog(LOG, "[DEBUG] FalconStatHandle result: NOT FOUND for name=%s", info->name);
             } else {
                 Datum datumArray[Natts_pg_dfs_inode_table];
                 bool isNullArray[Natts_pg_dfs_inode_table];
@@ -683,6 +688,9 @@ void FalconStatHandle(MetaProcessInfo *infoArray, int count)
                 info->st_mtim = DatumGetInt64(datumArray[Anum_pg_dfs_file_st_mtim - 1]);
                 info->st_ctim = DatumGetInt64(datumArray[Anum_pg_dfs_file_st_ctim - 1]);
                 info->etag = TextDatumGetCString(datumArray[Anum_pg_dfs_file_etag - 1]);
+                if (!isNullArray[Anum_pg_dfs_file_primary_nodeid - 1]) {
+                    info->node_id = DatumGetInt32(datumArray[Anum_pg_dfs_file_primary_nodeid - 1]);
+                }
             }
             systable_endscan(scanDescriptor);
         }
@@ -1269,6 +1277,8 @@ void FalconRmdirHandle(MetaProcessInfo info)
                               "RmdirSubUnlink is supposed to be successful, "
                               "but it failed.");
     }
+
+    info->errorCode = SUCCESS;
 }
 
 void FalconRmdirSubRmdirHandle(MetaProcessInfo info)
@@ -1351,7 +1361,7 @@ void FalconRmdirSubUnlinkHandle(MetaProcessInfo info)
                                                    NULL,
                                                    NULL,
                                                    &nlink,
-                                                   -1,
+                                                   -2,
                                                    NULL,
                                                    NULL,
                                                    NULL,
@@ -1362,7 +1372,7 @@ void FalconRmdirSubUnlinkHandle(MetaProcessInfo info)
                                                    NULL,
                                                    NULL,
                                                    NULL);
-    if (nlink != 1)
+    if (nlink != 2)
         FALCON_ELOG_ERROR(PROGRAM_ERROR, "unexpected.");
     if (!fileExist)
         FALCON_ELOG_ERROR_EXTENDED(FILE_NOT_EXISTS,
@@ -1950,6 +1960,34 @@ static StringInfo __attribute__((unused)) GetXattrIndexShardName(int shardId)
     return xattrIndexShardName;
 }
 
+static StringInfo GetSliceShardName(int shardId)
+{
+    StringInfo sliceShardName = makeStringInfo();
+    appendStringInfo(sliceShardName, "%s_%d", SliceTableName, shardId);
+    return sliceShardName;
+}
+
+static StringInfo GetSliceIndexShardName(int shardId)
+{
+    StringInfo sliceIndexShardName = makeStringInfo();
+    appendStringInfo(sliceIndexShardName, "%s_%d_%s", SliceTableName, shardId, "index");
+    return sliceIndexShardName;
+}
+
+static StringInfo GetKvmetaShardName(int shardId)
+{
+    StringInfo kvmetaShardName = makeStringInfo();
+    appendStringInfo(kvmetaShardName, "%s_%d", KvmetaTableName, shardId);
+    return kvmetaShardName;
+}
+
+static StringInfo GetKvmetaIndexShardName(int shardId)
+{
+    StringInfo kvmetaIndexShardName = makeStringInfo();
+    appendStringInfo(kvmetaIndexShardName, "%s_%d_%s", KvmetaTableName, shardId, "index");
+    return kvmetaIndexShardName;
+}
+
 static Oid GetRelationOidByName_FALCON(const char *relationName)
 {
     Oid res = InvalidOid;
@@ -2188,3 +2226,436 @@ static bool InsertIntoInodeTable(Relation relation,
     CommandCounterIncrement();
     return true;
 }
+
+void FalconSlicePutHandle(SliceProcessInfo *infoArray, int count)
+{
+    for (int i = 0; i < count; ++i) {
+        SliceProcessInfo info = infoArray[i];
+        info->errorCode = SUCCESS;
+
+        int shardId, workerId;
+        uint16_t partId = HashPartId(info->name);
+        SearchShardInfoByShardValue(partId, &shardId, &workerId);
+        if (workerId != GetLocalServerId())
+            CHECK_ERROR_CODE_WITH_RETURN(WRONG_WORKER);
+
+        StringInfo sliceShardName = GetSliceShardName(shardId);
+        Relation sliceRel = table_open(GetRelationOidByName_FALCON(sliceShardName->data), RowExclusiveLock);
+        CatalogIndexState indexState = CatalogOpenIndexes(sliceRel);
+        TupleDesc tupleDesc = RelationGetDescr(sliceRel);
+        for (int j = 0; j < info->count; ++j) {
+            Datum values[Natts_falcon_slice_table];
+            bool isNulls[Natts_falcon_slice_table];
+            memset(values, 0, sizeof(values));
+            memset(isNulls, false, sizeof(isNulls));
+
+            values[Anum_falcon_slice_table_inodeid - 1] = UInt64GetDatum(info->inodeIds[j]);
+            values[Anum_falcon_slice_table_chunkid - 1] = UInt32GetDatum(info->chunkIds[j]);
+            values[Anum_falcon_slice_table_sliceid - 1] = UInt64GetDatum(info->sliceIds[j]);
+            values[Anum_falcon_slice_table_slicesize - 1] = UInt32GetDatum(info->sliceSizes[j]);
+            values[Anum_falcon_slice_table_sliceoffset - 1] = UInt32GetDatum(info->sliceOffsets[j]);
+            values[Anum_falcon_slice_table_slicelen - 1] = UInt32GetDatum(info->sliceLens[j]);
+            values[Anum_falcon_slice_table_sliceloc1 - 1] = UInt32GetDatum(info->sliceLoc1s[j]);
+            values[Anum_falcon_slice_table_sliceloc2 - 1] = UInt32GetDatum(info->sliceloc2s[j]);
+
+            HeapTuple heapTuple = heap_form_tuple(tupleDesc, values, isNulls);
+            CatalogTupleInsertWithInfo(sliceRel, heapTuple, indexState);
+            heap_freetuple(heapTuple);
+        }
+
+        CatalogCloseIndexes(indexState);
+        table_close(sliceRel, RowExclusiveLock);
+    }
+}
+
+void FalconSliceGetHandle(SliceProcessInfo *infoArray, int count)
+{
+    SetUpScanCaches();
+
+    for (int i = 0; i < count; ++i) {
+        SliceProcessInfo info = infoArray[i];
+
+        int shardId, workerId;
+        uint16_t partId = HashPartId(info->name);
+        SearchShardInfoByShardValue(partId, &shardId, &workerId);
+        if (workerId != GetLocalServerId())
+            CHECK_ERROR_CODE_WITH_RETURN(WRONG_WORKER);
+
+        ScanKeyData scanKey[LAST_FALCON_SLICE_TABLE_SCANKEY_TYPE];
+        scanKey[SLICE_TABLE_INODEID_EQ] = SliceTableScanKey[SLICE_TABLE_INODEID_EQ];
+        scanKey[SLICE_TABLE_INODEID_EQ].sk_argument = UInt64GetDatum(info->inputInodeid);
+        scanKey[SLICE_TABLE_CHUNKID_EQ] = SliceTableScanKey[SLICE_TABLE_CHUNKID_EQ];
+        scanKey[SLICE_TABLE_CHUNKID_EQ].sk_argument = UInt32GetDatum(info->inputChunkid);
+
+        StringInfo sliceShardName = GetSliceShardName(shardId);
+        StringInfo sliceIndexShardName = GetSliceIndexShardName(shardId);
+
+        Relation sliceRel = table_open(GetRelationOidByName_FALCON(sliceShardName->data), RowExclusiveLock);
+        SysScanDesc scanDesc = systable_beginscan(sliceRel,
+                                                GetRelationOidByName_FALCON(sliceIndexShardName->data),
+                                                true,
+                                                GetTransactionSnapshot(),
+                                                LAST_FALCON_SLICE_TABLE_SCANKEY_TYPE,
+                                                scanKey);
+        TupleDesc tupleDesc = RelationGetDescr(sliceRel);
+
+        bool isNull;
+        List *getResult = NIL;
+        HeapTuple heapTuple;
+        while (HeapTupleIsValid(heapTuple = systable_getnext(scanDesc))) {
+            SliceInfo *result = palloc(sizeof(SliceInfo));
+            result->inodeId = DatumGetUInt64(heap_getattr(heapTuple, Anum_falcon_slice_table_inodeid, tupleDesc, &isNull));
+            result->chunkId = DatumGetUInt32(heap_getattr(heapTuple, Anum_falcon_slice_table_chunkid, tupleDesc, &isNull));
+            result->sliceId = DatumGetUInt64(heap_getattr(heapTuple, Anum_falcon_slice_table_sliceid, tupleDesc, &isNull));
+            result->sliceSize = DatumGetUInt32(heap_getattr(heapTuple, Anum_falcon_slice_table_slicesize, tupleDesc, &isNull));
+            result->sliceOffset = DatumGetUInt32(heap_getattr(heapTuple, Anum_falcon_slice_table_sliceoffset, tupleDesc, &isNull));
+            result->sliceLen = DatumGetUInt32(heap_getattr(heapTuple, Anum_falcon_slice_table_slicelen, tupleDesc, &isNull));
+            result->sliceLoc1 = DatumGetUInt32(heap_getattr(heapTuple, Anum_falcon_slice_table_sliceloc1, tupleDesc, &isNull));
+            result->sliceLoc2 = DatumGetUInt32(heap_getattr(heapTuple, Anum_falcon_slice_table_sliceloc2, tupleDesc, &isNull));
+            getResult = lappend(getResult, result);
+        }
+
+        systable_endscan(scanDesc);
+        table_close(sliceRel, RowExclusiveLock);
+
+        /* if result is NIL */
+        if (getResult == NIL) {
+            info->errorCode = FILE_NOT_EXISTS;
+            info->count = 0;
+            continue;
+        }
+
+        SliceInfo **infos = (SliceInfo **)getResult->elements;
+        info->count = list_length(getResult);
+        info->inodeIds = (uint64_t *)palloc(sizeof(uint64_t) * info->count);
+        info->chunkIds = (uint32_t *)palloc(sizeof(uint32_t) * info->count);
+        info->sliceIds = (uint64_t *)palloc(sizeof(uint64_t) * info->count);
+        info->sliceSizes = (uint32_t *)palloc(sizeof(uint32_t) * info->count);
+        info->sliceOffsets = (uint32_t *)palloc(sizeof(uint32_t) * info->count);
+        info->sliceLens = (uint32_t *)palloc(sizeof(uint32_t) * info->count);
+        info->sliceLoc1s = (uint32_t *)palloc(sizeof(uint32_t) * info->count);
+        info->sliceloc2s = (uint32_t *)palloc(sizeof(uint32_t) * info->count);
+
+        for (uint32_t i = 0; i < info->count; ++i) {
+            info->inodeIds[i] = infos[i]->inodeId;
+            info->chunkIds[i] = infos[i]->chunkId;
+            info->sliceIds[i] = infos[i]->sliceId;
+            info->sliceSizes[i] = infos[i]->sliceSize;
+            info->sliceOffsets[i] = infos[i]->sliceOffset;
+            info->sliceLens[i] = infos[i]->sliceLen;
+            info->sliceLoc1s[i] = infos[i]->sliceLoc1;
+            info->sliceloc2s[i] = infos[i]->sliceLoc2;
+        }
+
+        info->errorCode = SUCCESS;
+    }
+}
+
+void FalconSliceDelHandle(SliceProcessInfo *infoArray, int count)
+{
+    SetUpScanCaches();
+
+    for (int i = 0; i < count; ++i) {
+        SliceProcessInfo info = infoArray[i];
+        info->errorCode = SUCCESS;
+
+        int shardId, workerId;
+        uint16_t partId = HashPartId(info->name);
+        SearchShardInfoByShardValue(partId, &shardId, &workerId);
+        if (workerId != GetLocalServerId())
+            CHECK_ERROR_CODE_WITH_RETURN(WRONG_WORKER);
+
+        ScanKeyData scanKey[LAST_FALCON_SLICE_TABLE_SCANKEY_TYPE];
+        scanKey[SLICE_TABLE_INODEID_EQ] = SliceTableScanKey[SLICE_TABLE_INODEID_EQ];
+        scanKey[SLICE_TABLE_INODEID_EQ].sk_argument = UInt64GetDatum(info->inputInodeid);
+        scanKey[SLICE_TABLE_CHUNKID_EQ] = SliceTableScanKey[SLICE_TABLE_CHUNKID_EQ];
+        scanKey[SLICE_TABLE_CHUNKID_EQ].sk_argument = UInt32GetDatum(info->inputChunkid);
+
+        StringInfo sliceShardName = GetSliceShardName(shardId);
+        StringInfo sliceIndexShardName = GetSliceIndexShardName(shardId);
+
+        Relation sliceRel = table_open(GetRelationOidByName_FALCON(sliceShardName->data), RowExclusiveLock);
+        SysScanDesc scanDesc = systable_beginscan(sliceRel,
+                                                GetRelationOidByName_FALCON(sliceIndexShardName->data),
+                                                true,
+                                                GetTransactionSnapshot(),
+                                                LAST_FALCON_SLICE_TABLE_SCANKEY_TYPE,
+                                                scanKey);
+        HeapTuple heapTuple;
+        while (HeapTupleIsValid(heapTuple = systable_getnext(scanDesc))) {
+            CatalogTupleDelete(sliceRel, &heapTuple->t_self);
+        }
+
+        systable_endscan(scanDesc);
+        table_close(sliceRel, RowExclusiveLock);
+    }
+}
+
+void FalconKvmetaPutHandle(KvMetaProcessInfo info)
+{
+    MemoryContext oldcontext = CurrentMemoryContext;
+
+    int shardId, workerId;
+    uint16_t partId = HashPartId(info->userkey);
+    SearchShardInfoByShardValue(partId, &shardId, &workerId);
+    if (workerId != GetLocalServerId())
+        CHECK_ERROR_CODE_WITH_RETURN(WRONG_WORKER);
+
+    StringInfo kvmetaShardName = GetKvmetaShardName(shardId);
+    Relation kvmetaRel = NULL;
+    TupleDesc tupleDesc = NULL;
+    Datum *dkeys = NULL;
+
+    kvmetaRel = table_open(GetRelationOidByName_FALCON(kvmetaShardName->data), RowExclusiveLock);
+    CatalogIndexState indexState = CatalogOpenIndexes(kvmetaRel);
+
+    PG_TRY();
+    {
+        tupleDesc = RelationGetDescr(kvmetaRel);
+
+        Datum values[Natts_falcon_kvmeta_table];
+        bool isNulls[Natts_falcon_kvmeta_table];
+        memset(values, 0, sizeof(values));
+        memset(isNulls, false, sizeof(isNulls));
+
+        values[Anum_falcon_kvmeta_table_userkey - 1] = CStringGetTextDatum(info->userkey);
+        values[Anum_falcon_kvmeta_table_valuelen - 1] = UInt32GetDatum(info->valuelen);
+        values[Anum_falcon_kvmeta_table_slicenum - 1] = UInt16GetDatum(info->slicenum);
+
+        ArrayType *arr = NULL;
+        int size = info->slicenum;
+        dkeys = palloc(size * sizeof(Datum));
+
+        for (int i = 0; i < size; i ++) {
+            dkeys[i] = UInt64GetDatum(info->valuekey[i]);
+        }
+        arr = construct_array(dkeys, size, INT8OID, sizeof(uint64_t), true, 'd');
+        values[Anum_falcon_kvmeta_table_valuekey - 1] = PointerGetDatum(arr);
+
+        for (int i = 0; i < size; i ++) {
+            dkeys[i] = UInt64GetDatum(info->location[i]);
+        }
+        arr = construct_array(dkeys, size, INT8OID, sizeof(uint64_t), true, 'd');
+        values[Anum_falcon_kvmeta_table_location - 1] = PointerGetDatum(arr);
+
+        for (int i = 0; i < size; i ++) {
+            dkeys[i] = UInt32GetDatum(info->slicelen[i]);
+        }
+        arr = construct_array(dkeys, size, INT4OID, sizeof(uint32_t), true, 'i');
+        values[Anum_falcon_kvmeta_table_slicelen - 1] = PointerGetDatum(arr);
+
+        pfree(dkeys);
+        dkeys = NULL;
+
+        HeapTuple heapTuple = heap_form_tuple(tupleDesc, values, isNulls);
+        CatalogTupleInsertWithInfo(kvmetaRel, heapTuple, indexState);
+        heap_freetuple(heapTuple);
+
+        CatalogCloseIndexes(indexState);
+        table_close(kvmetaRel, RowExclusiveLock);
+    }
+    PG_CATCH();
+    {
+        MemoryContextSwitchTo(oldcontext);
+        ErrorData *errorData = CopyErrorData();
+        FlushErrorState();
+
+        if (dkeys != NULL) {
+            pfree(dkeys);
+            dkeys = NULL;
+        }
+
+        CatalogCloseIndexes(indexState);
+        if (kvmetaRel != NULL) {
+            table_close(kvmetaRel, RowExclusiveLock);
+        }
+
+        info->errorCode = errorData->sqlerrcode == ERRCODE_UNIQUE_VIOLATION ? SUCCESS : UNKNOWN;
+        FreeErrorData(errorData);
+    }
+    PG_END_TRY();
+}
+
+void FalconKvmetaGetHandle(KvMetaProcessInfo info)
+{
+    int shardId, workerId;
+    uint16_t partId = HashPartId(info->userkey);
+    SearchShardInfoByShardValue(partId, &shardId, &workerId);
+    if (workerId != GetLocalServerId())
+        CHECK_ERROR_CODE_WITH_RETURN(WRONG_WORKER);
+
+    SetUpScanCaches();
+
+    ScanKeyData scanKey[LAST_FALCON_KVMETA_TABLE_SCANKEY_TYPE];
+    scanKey[KVMETA_TABLE_USERKEY_EQ] = KvmetaTableScanKey[KVMETA_TABLE_USERKEY_EQ];
+    scanKey[KVMETA_TABLE_USERKEY_EQ].sk_argument = CStringGetTextDatum(info->userkey);
+
+    StringInfo kvmetaShardName = GetKvmetaShardName(shardId);
+    StringInfo kvmetaIndexShardName = GetKvmetaIndexShardName(shardId);
+
+    Relation kvmetaRel = table_open(GetRelationOidByName_FALCON(kvmetaShardName->data), AccessShareLock);
+    SysScanDesc scanDesc = systable_beginscan(kvmetaRel,
+                                              GetRelationOidByName_FALCON(kvmetaIndexShardName->data),
+                                              true,
+                                              GetTransactionSnapshot(),
+                                              LAST_FALCON_KVMETA_TABLE_SCANKEY_TYPE,
+                                              scanKey);
+    TupleDesc tupleDesc = RelationGetDescr(kvmetaRel);
+    HeapTuple heapTuple = systable_getnext(scanDesc);
+    if (!HeapTupleIsValid(heapTuple)) {
+        systable_endscan(scanDesc);
+        table_close(kvmetaRel, AccessShareLock);
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "FalconKvmetaGetHandle has received invalid input.");
+    }
+
+    bool isNull;
+    ArrayType *arr = NULL;
+    info->valuelen = DatumGetUInt32(heap_getattr(heapTuple, Anum_falcon_kvmeta_table_valuelen, tupleDesc, &isNull));
+    info->slicenum = DatumGetUInt16(heap_getattr(heapTuple, Anum_falcon_kvmeta_table_slicenum, tupleDesc, &isNull));
+
+    int ndim;
+    int nitems;
+    int16 typlen;
+    bool typbyval;
+    char typalign;
+    int* dims = NULL;
+    Datum *array = NULL;
+
+    info->valuekey = palloc(info->slicenum * sizeof(uint64_t));
+    info->location = palloc(info->slicenum * sizeof(uint64_t));
+    info->slicelen = palloc(info->slicenum * sizeof(uint32_t));
+
+    arr = DatumGetArrayTypeP(heap_getattr(heapTuple, Anum_falcon_kvmeta_table_valuekey, tupleDesc, &isNull));
+    get_typlenbyvalalign(ARR_ELEMTYPE(arr), &typlen, &typbyval, &typalign);
+    ndim = ARR_NDIM(arr);
+    dims = ARR_DIMS(arr);
+    nitems = ArrayGetNItems(ndim, dims);
+    deconstruct_array(arr, INT8OID, typlen, typbyval, typalign, &array, NULL, &nitems);
+    for (int i = 0; i < nitems; i++) {
+        info->valuekey[i] = DatumGetUInt64(array[i]);
+    }
+    if (array != NULL) {
+        pfree(array);
+        array = NULL;
+    }
+
+    arr = DatumGetArrayTypeP(heap_getattr(heapTuple, Anum_falcon_kvmeta_table_location, tupleDesc, &isNull));
+    get_typlenbyvalalign(ARR_ELEMTYPE(arr), &typlen, &typbyval, &typalign);
+    ndim = ARR_NDIM(arr);
+    dims = ARR_DIMS(arr);
+    nitems = ArrayGetNItems(ndim, dims);
+    deconstruct_array(arr, INT8OID, typlen, typbyval, typalign, &array, NULL, &nitems);
+    for (int i = 0; i < nitems; i++) {
+        info->location[i] = DatumGetUInt64(array[i]);
+    }
+    if (array != NULL) {
+        pfree(array);
+        array = NULL;
+    }
+
+    arr = DatumGetArrayTypeP(heap_getattr(heapTuple, Anum_falcon_kvmeta_table_slicelen, tupleDesc, &isNull));
+    get_typlenbyvalalign(ARR_ELEMTYPE(arr), &typlen, &typbyval, &typalign);
+    ndim = ARR_NDIM(arr);
+    dims = ARR_DIMS(arr);
+    nitems = ArrayGetNItems(ndim, dims);
+    deconstruct_array(arr, INT4OID, typlen, typbyval, typalign, &array, NULL, &nitems);
+    for (int i = 0; i < nitems; i++) {
+        info->slicelen[i] = DatumGetUInt32(array[i]);
+    }
+    if (array != NULL) {
+        pfree(array);
+        array = NULL;
+    }
+
+    systable_endscan(scanDesc);
+    table_close(kvmetaRel, AccessShareLock);
+}
+
+void FalconKvmetaDelHandle(KvMetaProcessInfo info)
+{
+    int shardId, workerId;
+    uint16_t partId = HashPartId(info->userkey);
+    SearchShardInfoByShardValue(partId, &shardId, &workerId);
+    if (workerId != GetLocalServerId())
+        CHECK_ERROR_CODE_WITH_RETURN(WRONG_WORKER);
+
+    SetUpScanCaches();
+
+    ScanKeyData scanKey[LAST_FALCON_KVMETA_TABLE_SCANKEY_TYPE];
+    scanKey[KVMETA_TABLE_USERKEY_EQ] = KvmetaTableScanKey[KVMETA_TABLE_USERKEY_EQ];
+    scanKey[KVMETA_TABLE_USERKEY_EQ].sk_argument = CStringGetTextDatum(info->userkey);
+
+    StringInfo kvmetaShardName = GetKvmetaShardName(shardId);
+    StringInfo kvmetaIndexShardName = GetKvmetaIndexShardName(shardId);
+
+    Relation kvmetaRel = table_open(GetRelationOidByName_FALCON(kvmetaShardName->data), RowExclusiveLock);
+    SysScanDesc scanDesc = systable_beginscan(kvmetaRel,
+                                              GetRelationOidByName_FALCON(kvmetaIndexShardName->data),
+                                              true,
+                                              GetTransactionSnapshot(),
+                                              LAST_FALCON_KVMETA_TABLE_SCANKEY_TYPE,
+                                              scanKey);
+    HeapTuple heapTuple = systable_getnext(scanDesc);
+    if (!HeapTupleIsValid(heapTuple)) {
+        systable_endscan(scanDesc);
+        table_close(kvmetaRel, RowExclusiveLock);
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "FalconKvmetaDelHandle has received invalid input.");
+    }
+
+    CatalogTupleDelete(kvmetaRel, &heapTuple->t_self);
+
+    systable_endscan(scanDesc);
+    table_close(kvmetaRel, RowExclusiveLock);
+}
+
+void FalconFetchSliceIdHandle(SliceIdProcessInfo info)
+{
+    SetUpScanCaches();
+
+    ScanKeyData scanKey[LAST_FALCON_SLICEID_TABLE_SCANKEY_TYPE];
+    scanKey[SLICEID_TABLE_SLICEID_EQ] = SliceIdTableScanKey[SLICEID_TABLE_SLICEID_EQ];
+    scanKey[SLICEID_TABLE_SLICEID_EQ].sk_argument = CStringGetTextDatum("slice_id");
+
+    Oid relationId = info->type == 0 ? KvSliceIdRelationId() : FileSliceIdRelationId();
+    Relation sliceIdRel = table_open(relationId, RowExclusiveLock);
+    SysScanDesc scanDesc = systable_beginscan(sliceIdRel, InvalidOid, true, GetTransactionSnapshot(),
+                                              LAST_FALCON_SLICEID_TABLE_SCANKEY_TYPE, scanKey);
+    TupleDesc tupleDesc = RelationGetDescr(sliceIdRel);
+    HeapTuple heapTuple = systable_getnext(scanDesc);
+
+    Datum values[Natts_falcon_sliceid_table];
+    bool isNulls[Natts_falcon_sliceid_table];
+    bool updates[Natts_falcon_sliceid_table];
+    memset(values, 0, sizeof(values));
+    memset(isNulls, false, sizeof(isNulls));
+    memset(updates, 0, sizeof(updates));
+
+    if (HeapTupleIsValid(heapTuple)) {
+        bool isNull;
+        info->start = DatumGetUInt64(heap_getattr(heapTuple, Anum_falcon_sliceid_table_sliceid, tupleDesc, &isNull));
+        info->end = info->start + info->count;
+
+        values[Anum_falcon_sliceid_table_sliceid - 1] = UInt64GetDatum(info->end);
+        updates[Anum_falcon_sliceid_table_sliceid - 1] = true;
+
+        HeapTuple updatedTuple = heap_modify_tuple(heapTuple, tupleDesc, values, isNulls, updates);
+        CatalogTupleUpdate(sliceIdRel, &updatedTuple->t_self, updatedTuple);
+        heap_freetuple(updatedTuple);
+        systable_endscan(scanDesc);
+    } else {
+        systable_endscan(scanDesc);
+
+        info->start = 0;
+        info->end = info->count;
+        values[Anum_falcon_sliceid_table_keystr - 1] = CStringGetTextDatum("slice_id");
+        values[Anum_falcon_sliceid_table_sliceid - 1] = UInt64GetDatum(info->end);
+
+        HeapTuple heapTuple = heap_form_tuple(tupleDesc, values, isNulls);
+        CatalogTupleInsert(sliceIdRel, heapTuple);
+        heap_freetuple(heapTuple);
+    }
+
+    table_close(sliceIdRel, RowExclusiveLock);
+
+    info->errorCode = SUCCESS;
+}
\ No newline at end of file
diff --git a/falcon/metadb/meta_serialize_interface.c b/falcon/metadb/meta_serialize_interface.c
index a9a34d4..4985b75 100644
--- a/falcon/metadb/meta_serialize_interface.c
+++ b/falcon/metadb/meta_serialize_interface.c
@@ -16,7 +16,7 @@
 PG_FUNCTION_INFO_V1(falcon_meta_call_by_serialized_shmem_internal);
 PG_FUNCTION_INFO_V1(falcon_meta_call_by_serialized_data);
 
-static SerializedData MetaProcess(FalconSupportMetaService metaService, int count, char *paramBuffer)
+static SerializedData FileMetaProcess(FalconSupportMetaService metaService, int count, char *paramBuffer)
 {
     if (count != 1 && !(metaService == MKDIR || metaService == MKDIR_SUB_MKDIR || metaService == MKDIR_SUB_CREATE ||
                         metaService == CREATE || metaService == STAT || metaService == OPEN || metaService == CLOSE ||
@@ -106,6 +106,122 @@ static SerializedData MetaProcess(FalconSupportMetaService metaService, int coun
     return response;
 }
 
+static SerializedData KVMetaProcess(FalconSupportMetaService metaService, char *paramBuffer)
+{
+    SerializedData param;
+
+    if (!SerializedDataInit(&param, paramBuffer, SD_SIZE_T_MAX, SD_SIZE_T_MAX, NULL))
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "SerializedDataInit failed.");
+    
+    KvMetaProcessInfoData infoData = {0};
+    if (!SerializedKvMetaParamDecode(metaService, &param, &infoData))
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "serialized param is corrupt.");
+
+    switch (metaService) {
+        case KV_PUT:
+            FalconKvmetaPutHandle(&infoData);
+            break;
+        case KV_GET:
+            FalconKvmetaGetHandle(&infoData);
+            break;
+        case KV_DEL:
+            FalconKvmetaDelHandle(&infoData);
+            break;
+        default:
+            FALCON_ELOG_ERROR_EXTENDED(ARGUMENT_ERROR, "unexpected metaService: %d", metaService);
+    }
+
+    SerializedData response;
+    SerializedDataInit(&response, NULL, 0, 0, &PgMemoryManager);
+    if (!SerializedKvMetaResponseEncodeWithPerProcessFlatBufferBuilder(metaService, &infoData, &response))
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "failed when serializing response.");
+
+    return response;
+}
+
+static SerializedData SliceMetaProcess(FalconSupportMetaService metaService, int count, char *paramBuffer)
+{
+    SerializedData param;
+
+    if (!SerializedDataInit(&param, paramBuffer, SD_SIZE_T_MAX, SD_SIZE_T_MAX, NULL))
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "SerializedDataInit failed.");
+
+    void *data = palloc((sizeof(SliceProcessInfoData) + sizeof(SliceProcessInfo)) * count);
+    SliceProcessInfoData *infoDataArray = data;
+    SliceProcessInfo *infoArray = (SliceProcessInfo *)(infoDataArray + count);
+    if (!SerializedSliceParamDecode(metaService, count, &param, infoDataArray))
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "serialized param is corrupt.");
+
+    for (int i = 0; i < count; i++) {
+        infoArray[i] = infoDataArray + i;
+    }
+
+    switch (metaService) {
+        case SLICE_PUT:
+            FalconSlicePutHandle(infoArray, count);
+            break;
+        case SLICE_GET:
+            FalconSliceGetHandle(infoArray, count);
+            break;
+        case SLICE_DEL:
+            FalconSliceDelHandle(infoArray, count);
+            break;
+        default:
+            FALCON_ELOG_ERROR_EXTENDED(ARGUMENT_ERROR, "unexpected metaService: %d", metaService);
+    }
+
+    SerializedData response;
+    SerializedDataInit(&response, NULL, 0, 0, &PgMemoryManager);
+    if (!SerializedSliceResponseEncodeWithPerProcessFlatBufferBuilder(metaService, count, infoDataArray, &response))
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "failed when serializing response.");
+
+    return response;
+}
+
+static SerializedData SliceIdProcess(char *paramBuffer)
+{
+    SerializedData param;
+
+    if (!SerializedDataInit(&param, paramBuffer, SD_SIZE_T_MAX, SD_SIZE_T_MAX, NULL))
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "SerializedDataInit failed.");
+    
+    SliceIdProcessInfoData infoData = {0};
+    if (!SerializedSliceIdParamDecode(&param, &infoData))
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "serialized param is corrupt.");
+
+    FalconFetchSliceIdHandle(&infoData);
+
+    SerializedData response;
+    SerializedDataInit(&response, NULL, 0, 0, &PgMemoryManager);
+    if (!SerializedSliceIdResponseEncodeWithPerProcessFlatBufferBuilder(&infoData, &response))
+        FALCON_ELOG_ERROR(ARGUMENT_ERROR, "failed when serializing response.");
+
+    return response;
+}
+
+static SerializedData MetaProcess(FalconSupportMetaService metaService, int count, char *paramBuffer)
+{
+    if (metaService >= PLAIN_COMMAND && metaService <= CHMOD) {
+        return FileMetaProcess(metaService, count, paramBuffer);
+    }
+
+    if (metaService >= KV_PUT && metaService <= KV_DEL) {
+        return KVMetaProcess(metaService, paramBuffer);
+    }
+
+    if (metaService >= SLICE_PUT && metaService <= SLICE_DEL) {
+        return SliceMetaProcess(metaService, count, paramBuffer);
+    }
+
+    if (metaService == FETCH_SLICE_ID) {
+        return SliceIdProcess(paramBuffer);
+    }
+
+    FALCON_ELOG_ERROR_EXTENDED(ARGUMENT_ERROR, "metaService %d doesn't support operation.", metaService);
+    SerializedData param;
+    return param;
+}
+
 Datum falcon_meta_call_by_serialized_shmem_internal(PG_FUNCTION_ARGS)
 {
     int32_t type = PG_GETARG_INT32(0);
diff --git a/falcon/metadb/meta_serialize_interface_helper.cpp b/falcon/metadb/meta_serialize_interface_helper.cpp
index 6343695..294addf 100644
--- a/falcon/metadb/meta_serialize_interface_helper.cpp
+++ b/falcon/metadb/meta_serialize_interface_helper.cpp
@@ -53,6 +53,20 @@ FalconSupportMetaService MetaServiceTypeDecode(int32_t type)
         return FalconSupportMetaService::CHOWN;
     case falcon::meta_proto::MetaServiceType::CHMOD:
         return FalconSupportMetaService::CHMOD;
+    case falcon::meta_proto::MetaServiceType::KV_PUT:
+        return FalconSupportMetaService::KV_PUT;
+    case falcon::meta_proto::MetaServiceType::KV_GET:
+        return FalconSupportMetaService::KV_GET;
+    case falcon::meta_proto::MetaServiceType::KV_DEL:
+        return FalconSupportMetaService::KV_DEL;
+    case falcon::meta_proto::MetaServiceType::SLICE_PUT:
+        return FalconSupportMetaService::SLICE_PUT;
+    case falcon::meta_proto::MetaServiceType::SLICE_GET:
+        return FalconSupportMetaService::SLICE_GET;
+    case falcon::meta_proto::MetaServiceType::SLICE_DEL:
+        return FalconSupportMetaService::SLICE_DEL;
+    case falcon::meta_proto::MetaServiceType::FETCH_SLICE_ID:
+        return FalconSupportMetaService::FETCH_SLICE_ID;
     default:
         return FalconSupportMetaService::NOT_SUPPORTED;
     }
@@ -99,6 +113,20 @@ int32_t MetaServiceTypeEncode(FalconSupportMetaService metaService)
         return falcon::meta_proto::MetaServiceType::CHOWN;
     case FalconSupportMetaService::CHMOD:
         return falcon::meta_proto::MetaServiceType::CHMOD;
+    case FalconSupportMetaService::KV_PUT:
+        return falcon::meta_proto::MetaServiceType::KV_PUT;
+    case FalconSupportMetaService::KV_GET:
+        return falcon::meta_proto::MetaServiceType::KV_GET;
+    case FalconSupportMetaService::KV_DEL:
+        return falcon::meta_proto::MetaServiceType::KV_DEL;
+    case FalconSupportMetaService::SLICE_PUT:
+        return falcon::meta_proto::MetaServiceType::SLICE_PUT;
+    case FalconSupportMetaService::SLICE_GET:
+        return falcon::meta_proto::MetaServiceType::SLICE_GET;
+    case FalconSupportMetaService::SLICE_DEL:
+        return falcon::meta_proto::MetaServiceType::SLICE_DEL;
+    case FalconSupportMetaService::FETCH_SLICE_ID:
+        return falcon::meta_proto::MetaServiceType::FETCH_SLICE_ID;
     default:
         return -1;
     }
@@ -659,3 +687,266 @@ bool SerializedDataMetaResponseEncodeWithPerProcessFlatBufferBuilder(FalconSuppo
 {
     return SerializedDataMetaResponseEncode(metaService, count, infoArray, FlatBufferBuilderPerProcess, response);
 }
+
+
+bool SerializedKvMetaParamDecode(FalconSupportMetaService metaService, SerializedData *param,
+    KvMetaProcessInfo infoData)
+{
+    uint8_t *buffer = (uint8_t *)param->buffer;
+    sd_size_t size = SerializedDataNextSeveralItemSize(param, 0, 1);
+    if (size == (sd_size_t) - 1) {
+        return false;
+    }
+    uint8_t *itemBuffer = (uint8_t *)buffer + SERIALIZED_DATA_ALIGNMENT;
+    size_t itemSize = size - SERIALIZED_DATA_ALIGNMENT;
+    flatbuffers::Verifier verifier(itemBuffer, itemSize);
+    if (!verifier.VerifyBuffer<falcon::meta_fbs::MetaParam>(NULL)) {
+        return false;
+    }
+    auto metaParam = falcon::meta_fbs::GetMetaParam(itemBuffer);
+    switch (metaService) {
+        case FalconSupportMetaService::KV_PUT: {
+            if (metaParam->param_type() != falcon::meta_fbs::AnyMetaParam::AnyMetaParam_KVParam) {
+                return false;
+            }
+            auto kvParam = metaParam->param_as_KVParam();
+            infoData->userkey = kvParam->key()->c_str();
+            infoData->valuelen = kvParam->value_len();
+            infoData->slicenum = kvParam->slice_num();
+            // vector
+            infoData->valuekey = const_cast<uint64_t*>(kvParam->value_key()->data());
+            infoData->location = const_cast<uint64_t*>(kvParam->location()->data());
+            infoData->slicelen = const_cast<uint32_t*>(kvParam->size()->data());
+            break;
+        }
+        case FalconSupportMetaService::KV_GET:
+        case FalconSupportMetaService::KV_DEL: {
+            // key only param
+            if (metaParam->param_type() != falcon::meta_fbs::AnyMetaParam::AnyMetaParam_KeyOnlyParam) {
+                return false;
+            }
+            infoData->userkey = metaParam->param_as_KeyOnlyParam()->key()->c_str();
+            break;
+        }
+        default:
+            return false;
+    }
+    return true;
+}
+
+static bool SerializedkVMetaResponseEncode(FalconSupportMetaService metaService,
+                                           KvMetaProcessInfo infoData,
+                                           flatbuffers::FlatBufferBuilder &builder,
+                                           SerializedData *response)
+{
+    builder.Clear();
+    flatbuffers::Offset<falcon::meta_fbs::MetaResponse> metaResponse;
+    if (infoData->errorCode != SUCCESS && infoData->errorCode != FILE_EXISTS) {
+        metaResponse = falcon::meta_fbs::CreateMetaResponse(builder, infoData->errorCode);
+    } else {
+        switch (metaService) {
+        case FalconSupportMetaService::KV_PUT:
+        case FalconSupportMetaService::KV_DEL: {
+            // error code only response
+            metaResponse = falcon::meta_fbs::CreateMetaResponse(builder, infoData->errorCode);
+            break;
+        }
+        case FalconSupportMetaService::KV_GET: {
+            auto valueKeyFB = builder.CreateVector(infoData->valuekey, infoData->slicenum);
+            auto locationFB = builder.CreateVector(infoData->location, infoData->slicenum);
+            auto slicelenFB = builder.CreateVector(infoData->slicelen, infoData->slicenum);
+            auto getkvmetaReponse = falcon::meta_fbs::CreateGetKVMetaResponse(builder,
+                                                                              infoData->valuelen,
+                                                                              infoData->slicenum,
+                                                                              valueKeyFB,
+                                                                              locationFB,
+                                                                              slicelenFB);
+           metaResponse = falcon::meta_fbs::CreateMetaResponse(builder,
+                                                               infoData->errorCode,
+                                                               falcon::meta_fbs::AnyMetaResponse_GetKVMetaResponse,
+                                                               getkvmetaReponse.Union());
+            break;
+        }
+        default:
+            return false;
+        }
+    }
+    builder.Finish(metaResponse);
+
+    char *buffer = SerializedDataApplyForSegment(response, builder.GetSize());
+    memcpy(buffer, builder.GetBufferPointer(), builder.GetSize());
+    return true;
+}
+
+bool SerializedKvMetaResponseEncodeWithPerProcessFlatBufferBuilder(FalconSupportMetaService metaService,
+                                                                   KvMetaProcessInfo infoData,
+                                                                   SerializedData *response)
+
+
+{
+    return SerializedkVMetaResponseEncode(metaService, infoData, FlatBufferBuilderPerProcess, response);
+}
+
+bool SerializedSliceParamDecode(FalconSupportMetaService metaService,
+                                int count,
+                                SerializedData *param,
+                                SliceProcessInfoData *infoArray)
+{
+    sd_size_t p = 0;
+    for (int i = 0; i < count; ++i) {
+        uint8_t *buffer = (uint8_t *)param->buffer + p;
+        sd_size_t size = SerializedDataNextSeveralItemSize(param, p, 1);
+        if (size == (sd_size_t) - 1) {
+            return false;
+        }
+
+        uint8_t *itemBuffer = (uint8_t *)buffer + SERIALIZED_DATA_ALIGNMENT;
+        size_t itemSize = size - SERIALIZED_DATA_ALIGNMENT;
+        flatbuffers::Verifier verifier(itemBuffer, itemSize);
+        if (!verifier.VerifyBuffer<falcon::meta_fbs::MetaParam>(NULL)) {
+            return false;
+        }
+        auto metaParam = falcon::meta_fbs::GetMetaParam(itemBuffer);
+
+        SliceProcessInfo info = infoArray + i;
+        switch (metaService) {
+            case FalconSupportMetaService::SLICE_PUT: {
+                if (metaParam->param_type() != falcon::meta_fbs::AnyMetaParam::AnyMetaParam_SliceInfoParam) {
+                    return false;
+                }
+                auto sliceParam = metaParam->param_as_SliceInfoParam();
+                info->name = sliceParam->filename()->c_str();
+                info->count = sliceParam->slicenum();
+                info->inodeIds = const_cast<uint64_t *>(sliceParam->inodeid()->data());
+                info->chunkIds = const_cast<uint32_t *>(sliceParam->chunkid()->data());
+                info->sliceIds = const_cast<uint64_t *>(sliceParam->sliceid()->data());
+                info->sliceSizes = const_cast<uint32_t *>(sliceParam->slicesize()->data());
+                info->sliceOffsets = const_cast<uint32_t *>(sliceParam->sliceoffset()->data());
+                info->sliceLens = const_cast<uint32_t *>(sliceParam->slicelen()->data());
+                info->sliceLoc1s = const_cast<uint32_t *>(sliceParam->sliceloc1()->data());
+                info->sliceloc2s = const_cast<uint32_t *>(sliceParam->sliceloc2()->data());
+                break;
+            }
+            case FalconSupportMetaService::SLICE_GET:
+            case FalconSupportMetaService::SLICE_DEL: {
+                if (metaParam->param_type() != falcon::meta_fbs::AnyMetaParam::AnyMetaParam_SliceIndexParam) {
+                    return false;
+                }
+                auto sliceParam = metaParam->param_as_SliceIndexParam();
+                info->name = sliceParam->filename()->c_str();
+                info->inputInodeid = sliceParam->inodeid();
+                info->inputChunkid = sliceParam->chunkid();
+                break;
+            }
+            default:
+                return false;
+        }
+
+        p += size;
+    }
+
+    return true;
+}
+
+static bool SerializedSliceResponseEncode(FalconSupportMetaService metaService,
+                                          int count,
+                                          SliceProcessInfoData *infoArray,
+                                          flatbuffers::FlatBufferBuilder &builder,
+                                          SerializedData *response)
+{
+    for (int i = 0; i < count; ++i) {
+        builder.Clear();
+        SliceProcessInfo info = infoArray + i;
+        flatbuffers::Offset<falcon::meta_fbs::MetaResponse> metaResponse;
+
+        switch (metaService) {
+            case FalconSupportMetaService::SLICE_PUT:
+            case FalconSupportMetaService::SLICE_DEL: {
+                metaResponse = falcon::meta_fbs::CreateMetaResponse(builder, info->errorCode);
+                break;
+            }
+            case FalconSupportMetaService::SLICE_GET: {
+                auto inodeIds = builder.CreateVector(info->inodeIds, info->count);
+                auto chunkIds = builder.CreateVector(info->chunkIds, info->count);
+                auto sliceIds = builder.CreateVector(info->sliceIds, info->count);
+                auto sliceSizes = builder.CreateVector(info->sliceSizes, info->count);
+                auto sliceOffsets = builder.CreateVector(info->sliceOffsets, info->count);
+                auto sliceLens = builder.CreateVector(info->sliceLens, info->count);
+                auto sliceLoc1s = builder.CreateVector(info->sliceLoc1s, info->count);
+                auto sliceloc2s = builder.CreateVector(info->sliceloc2s, info->count);
+
+                auto sliceResponse = falcon::meta_fbs::CreateSliceInfoResponse(
+                    builder, info->count, inodeIds, chunkIds, sliceIds, sliceSizes,
+                    sliceOffsets, sliceLens, sliceLoc1s, sliceloc2s
+                );
+
+                metaResponse = falcon::meta_fbs::CreateMetaResponse(builder,
+                                                                    info->errorCode,
+                                                                    falcon::meta_fbs::AnyMetaResponse_SliceInfoResponse,
+                                                                    sliceResponse.Union());
+                break;
+            }
+            default:
+                return false;
+        }
+
+        builder.Finish(metaResponse);
+
+        char *buffer = SerializedDataApplyForSegment(response, builder.GetSize());
+        memcpy(buffer, builder.GetBufferPointer(), builder.GetSize());
+    }
+    return true;
+}
+
+bool SerializedSliceResponseEncodeWithPerProcessFlatBufferBuilder(FalconSupportMetaService metaService,
+                                                                  int count,
+                                                                  SliceProcessInfoData *infoArray,
+                                                                  SerializedData *response)
+{
+    return SerializedSliceResponseEncode(metaService, count, infoArray, FlatBufferBuilderPerProcess, response);
+}
+
+bool SerializedSliceIdParamDecode(SerializedData *param, SliceIdProcessInfo infoData)
+{
+    uint8_t *buffer = (uint8_t *)param->buffer;
+    sd_size_t size = SerializedDataNextSeveralItemSize(param, 0, 1);
+    if (size == (sd_size_t) - 1) {
+        return false;
+    }
+
+    uint8_t *itemBuffer = (uint8_t *)buffer + SERIALIZED_DATA_ALIGNMENT;
+    size_t itemSize = size - SERIALIZED_DATA_ALIGNMENT;
+    flatbuffers::Verifier verifier(itemBuffer, itemSize);
+    if (!verifier.VerifyBuffer<falcon::meta_fbs::MetaParam>(NULL)) {
+        return false;
+    }
+
+    auto metaParam = falcon::meta_fbs::GetMetaParam(itemBuffer);
+    if (metaParam->param_type() != falcon::meta_fbs::AnyMetaParam::AnyMetaParam_SliceIdParam) {
+        return false;
+    }
+
+    auto sliceIdParam = metaParam->param_as_SliceIdParam();
+    infoData->count = sliceIdParam->count();
+    infoData->type = sliceIdParam->type();
+
+    return true;
+}
+
+bool SerializedSliceIdResponseEncodeWithPerProcessFlatBufferBuilder(SliceIdProcessInfo infoData, SerializedData *response)
+{
+    auto &builder = FlatBufferBuilderPerProcess;
+    builder.Clear();
+
+    auto sliceIdRes = falcon::meta_fbs::CreateSliceIdResponse(builder, infoData->start, infoData->end);
+    auto metaResponse = falcon::meta_fbs::CreateMetaResponse(builder,
+                                                             infoData->errorCode,
+                                                             falcon::meta_fbs::AnyMetaResponse_SliceIdResponse,
+                                                             sliceIdRes.Union());
+
+    builder.Finish(metaResponse);
+    char *buffer = SerializedDataApplyForSegment(response, builder.GetSize());
+    memcpy(buffer, builder.GetBufferPointer(), builder.GetSize());
+
+    return true;
+}
\ No newline at end of file
diff --git a/falcon/metadb/slice_table.c b/falcon/metadb/slice_table.c
new file mode 100644
index 0000000..aaec775
--- /dev/null
+++ b/falcon/metadb/slice_table.c
@@ -0,0 +1,32 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#include "metadb/slice_table.h"
+
+
+const char *SliceTableName = "falcon_slice_table";
+
+void ConstructCreateSliceTableCommand(StringInfo command, const char *name)
+{
+    appendStringInfo(command,
+                     "CREATE TABLE falcon.%s("
+                     "inodeid    bigint,"
+                     "chunkid    int,"
+                     "sliceid    bigint,"
+                     "slicesize  int,"
+                     "sliceoffset int,"
+                     "slicelen   int,"
+                     "sliceloc1  int,"
+                     "sliceloc2  int);"
+                     "CREATE INDEX %s_index ON falcon.%s USING btree(inodeid, chunkid);"
+                     "ALTER TABLE falcon.%s SET SCHEMA pg_catalog;"
+                     "GRANT SELECT ON pg_catalog.%s TO public;"
+                     "ALTER EXTENSION falcon ADD TABLE %s;",
+                     name,
+                     name,
+                     name,
+                     name,
+                     name,
+                     name);
+}
\ No newline at end of file
diff --git a/falcon/metadb/sliceid_table.c b/falcon/metadb/sliceid_table.c
new file mode 100644
index 0000000..151d3d8
--- /dev/null
+++ b/falcon/metadb/sliceid_table.c
@@ -0,0 +1,23 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#include "metadb/sliceid_table.h"
+#include "utils/utils.h"
+
+const char *KvSliceIdTableName = "falcon_kvsliceid_table";
+const char *FileSliceIdTableName = "falcon_filesliceid_table";
+
+Oid KvSliceIdRelationId(void)
+{
+    GetRelationOid(KvSliceIdTableName, &CachedRelationOid[CACHED_RELATION_KVSLICEID_TABLE]);
+    return CachedRelationOid[CACHED_RELATION_KVSLICEID_TABLE];
+}
+
+Oid FileSliceIdRelationId(void)
+{
+    GetRelationOid(FileSliceIdTableName, &CachedRelationOid[CACHED_RELATION_FILESLICEID_TABLE]);
+    return CachedRelationOid[CACHED_RELATION_FILESLICEID_TABLE];
+}
+
+
diff --git a/falcon/plugin/falcon_plugin_loader.c b/falcon/plugin/falcon_plugin_loader.c
new file mode 100644
index 0000000..027ed0e
--- /dev/null
+++ b/falcon/plugin/falcon_plugin_loader.c
@@ -0,0 +1,573 @@
+/* Copyright (c) 2025 Huawei Technologies Co., Ltd.
+ * SPDX-License-Identifier: MulanPSL-2.0
+ */
+
+#include "postgres.h"
+#include "fmgr.h"
+#include "utils/elog.h"
+#include "postmaster/bgworker.h"
+#include "storage/ipc.h"
+#include "storage/proc.h"
+#include "storage/shmem.h"
+#include "storage/lwlock.h"
+#include "miscadmin.h"
+#include "tcop/tcopprot.h"
+
+#include "plugin/falcon_plugin_framework.h"
+#include "plugin/falcon_plugin_loader.h"
+#include "utils/falcon_plugin_guc.h"
+#include "connection_pool/connection_pool_config.h"
+#include "postmaster/postmaster.h"
+#include "metadb/foreign_server.h"
+#include "access/xact.h"
+#include "access/xlog.h"
+#include "utils/memutils.h"
+#include "storage/proc.h"
+#include "utils/resowner.h"
+#include <dlfcn.h>
+#include <dirent.h>
+#include <string.h>
+#include <stdlib.h>
+
+/* 声明外部函数 */
+extern bool CheckFalconHasBeenLoaded(void);
+extern bool RecoveryInProgress(void);
+
+typedef struct SavedBackgroundPluginInfo {
+    char plugin_path[FALCON_PLUGIN_MAX_PATH_SIZE];
+    char plugin_name[FALCON_PLUGIN_MAX_NAME_SIZE];
+    falcon_plugin_init_func_t init_func;
+    void *dl_handle;  /* 保持 dl_handle 打开，以便后续调用 */
+} SavedBackgroundPluginInfo;
+
+static FalconPluginSharedMemory *falcon_plugin_shmem = NULL;
+static bool falcon_plugin_shmem_initialized = false;
+static char *saved_plugin_directory = NULL;
+static shmem_startup_hook_type prev_plugin_shmem_startup_hook = NULL;
+
+static SavedBackgroundPluginInfo saved_background_plugins[FALCON_PLUGIN_MAX_PLUGINS];
+static int saved_background_plugin_count = 0;
+
+static int FalconRegisterBackgroundPlugins(const char *plugin_dir);
+static int FalconExecuteInlinePlugins(const char *plugin_dir);
+static void FalconPluginShmemStartupHook(void);
+static int FalconPluginGetFreeSlot(void);
+static void FalconPluginReleaseSlot(int slot_index);
+static void FalconPluginInitializeSlot(int slot_index, const char *plugin_name, const char *plugin_path);
+
+Size FalconPluginShmemSize(void)
+{
+    return sizeof(FalconPluginSharedMemory);
+}
+
+void FalconPluginShmemInit(void)
+{
+    bool found;
+    Size size = sizeof(FalconPluginSharedMemory);
+
+    falcon_plugin_shmem = (FalconPluginSharedMemory *)
+        ShmemInitStruct("FalconPluginSharedMemory", size, &found);
+    
+    if (!found) {
+        memset(falcon_plugin_shmem, 0, size);
+        falcon_plugin_shmem->num_slots = FALCON_PLUGIN_MAX_PLUGINS;
+
+        for (int i = 0; i < FALCON_PLUGIN_MAX_PLUGINS; i++) {
+            falcon_plugin_shmem->plugins[i].in_use = false;
+        }
+        
+        ereport(LOG, (errmsg("Initialized plugin shared memory with %d slots", FALCON_PLUGIN_MAX_PLUGINS)));
+    }
+
+    falcon_plugin_shmem_initialized = true;
+}
+
+
+void FalconPluginInitBackgroundPlugins(void)
+{
+    ereport(LOG, (errmsg("Calling saved init_func for %d background plugins", saved_background_plugin_count)));
+
+    for (int i = 0; i < saved_background_plugin_count; i++) {
+        SavedBackgroundPluginInfo *saved = &saved_background_plugins[i];
+        int slot_index;
+        FalconPluginData *plugin_data;
+        int ret;
+
+        /* 分配共享内存槽位 */
+        slot_index = FalconPluginGetFreeSlot();
+        if (slot_index < 0) {
+            ereport(WARNING, (errmsg("Cannot allocate shared memory slot for plugin %s", saved->plugin_name)));
+            dlclose(saved->dl_handle);
+            continue;
+        }
+
+        /* 初始化槽位 */
+        FalconPluginInitializeSlot(slot_index, saved->plugin_name, saved->plugin_path);
+        plugin_data = &falcon_plugin_shmem->plugins[slot_index];
+
+        ereport(LOG, (errmsg("Calling init_func for background plugin %s in main process (slot %d)",
+                            saved->plugin_name, slot_index)));
+        ret = saved->init_func(plugin_data);
+        if (ret != 0) {
+            ereport(WARNING, (errmsg("Plugin %s init_func failed with code %d", saved->plugin_name, ret)));
+            FalconPluginReleaseSlot(slot_index);
+        }
+
+        /* 关闭 dl_handle */
+        dlclose(saved->dl_handle);
+    }
+
+    ereport(LOG, (errmsg("Finished calling init_func for all background plugins")));
+}
+
+static int FalconPluginGetFreeSlot(void)
+{
+    if (!falcon_plugin_shmem_initialized) {
+        FalconPluginShmemInit();
+    }
+
+    for (int i = 0; i < falcon_plugin_shmem->num_slots; i++) {
+        if (!falcon_plugin_shmem->plugins[i].in_use) {
+            falcon_plugin_shmem->plugins[i].in_use = true;
+            return i;
+        }
+    }
+
+    return -1;  /* No free slots available */
+}
+
+static void FalconPluginReleaseSlot(int slot_index)
+{
+    if (slot_index < 0 || slot_index >= falcon_plugin_shmem->num_slots) {
+        return;
+    }
+
+    FalconPluginData *plugin_data = &falcon_plugin_shmem->plugins[slot_index];
+
+    memset(plugin_data, 0, sizeof(FalconPluginData));
+    plugin_data->in_use = false;
+}
+
+/*
+ * Load plugin shared library and validate required functions
+ * Returns dl_handle on success, NULL on failure
+ */
+static void *FalconPluginLoadAndValidate(const char *plugin_path, const char *plugin_name,
+                                         falcon_plugin_init_func_t *init_func,
+                                         falcon_plugin_get_type_func_t *get_type_func,
+                                         falcon_plugin_work_func_t *work_func,
+                                         falcon_plugin_cleanup_func_t *cleanup_func)
+{
+    void *dl_handle = dlopen(plugin_path, RTLD_LAZY);
+    if (!dl_handle) {
+        ereport(WARNING, (errmsg("Failed to load plugin %s: %s", plugin_path, dlerror())));
+        return NULL;
+    }
+
+    *init_func = (falcon_plugin_init_func_t)dlsym(dl_handle, FALCON_PLUGIN_INIT_FUNC_NAME);
+    *get_type_func = (falcon_plugin_get_type_func_t)dlsym(dl_handle, FALCON_PLUGIN_GET_TYPE_FUNC_NAME);
+    *work_func = (falcon_plugin_work_func_t)dlsym(dl_handle, FALCON_PLUGIN_WORK_FUNC_NAME);
+    *cleanup_func = (falcon_plugin_cleanup_func_t)dlsym(dl_handle, FALCON_PLUGIN_CLEANUP_FUNC_NAME);
+
+    if (!*init_func || !*get_type_func || !*work_func || !*cleanup_func) {
+        ereport(WARNING, (errmsg("Plugin %s missing required functions", plugin_name)));
+        dlclose(dl_handle);
+        return NULL;
+    }
+
+    return dl_handle;
+}
+
+static void FalconPluginInitializeSlot(int slot_index, const char *plugin_name, const char *plugin_path)
+{
+    FalconPluginData *plugin_data = &falcon_plugin_shmem->plugins[slot_index];
+
+    memset(plugin_data, 0, sizeof(FalconPluginData));
+    plugin_data->in_use = true;
+    strncpy(plugin_data->plugin_name, plugin_name, FALCON_PLUGIN_MAX_NAME_SIZE - 1);
+    strncpy(plugin_data->plugin_path, plugin_path, FALCON_PLUGIN_MAX_PATH_SIZE - 1);
+    plugin_data->main_pid = getpid();
+
+    ereport(LOG, (errmsg("Plugin %s allocated slot %d", plugin_name, slot_index)));
+}
+
+/* 获取当前节点信息 - 供插件使用 */
+void FalconPluginGetNodeInfo(FalconNodeInfo *node_info)
+{
+    if (node_info == NULL) {
+        return;
+    }
+
+    /* 设置节点信息 */
+    const char *ip = FalconNodeLocalIp ? FalconNodeLocalIp : "127.0.0.1";
+    strncpy(node_info->node_ip, ip, sizeof(node_info->node_ip) - 1);
+    node_info->node_ip[sizeof(node_info->node_ip) - 1] = '\0';
+    node_info->node_port = PostPortNumber;  /* PostgreSQL 端口 */
+    node_info->pooler_port = FalconConnectionPoolPort;  /* 连接池端口 */
+
+    ereport(LOG, (errmsg("FalconPluginGetNodeInfo: %s:%d (pooler=%d)",
+                        node_info->node_ip, node_info->node_port,
+                        node_info->pooler_port)));
+}
+
+static int FalconPluginExecuteInline(int slot_index, const char *plugin_name,
+                                     falcon_plugin_init_func_t init_func,
+                                     falcon_plugin_work_func_t work_func,
+                                     falcon_plugin_cleanup_func_t cleanup_func)
+{
+    FalconPluginData *plugin_data = &falcon_plugin_shmem->plugins[slot_index];
+    int ret;
+
+    ret = init_func(plugin_data);
+    if (ret != 0) {
+        ereport(WARNING, (errmsg("Plugin %s initialization failed with code %d", plugin_name, ret)));
+        return -1;
+    }
+
+    ret = work_func(plugin_data);
+    ereport(LOG, (errmsg("Plugin %s INLINE execution result: %d", plugin_name, ret)));
+
+    cleanup_func(plugin_data);
+
+    return 0;
+}
+
+/*
+ * Internal shmem startup hook to execute INLINE plugins
+ * This is called automatically after FalconPluginShmemInit()
+ */
+static void FalconPluginShmemStartupHook(void)
+{
+    if (prev_plugin_shmem_startup_hook) {
+        prev_plugin_shmem_startup_hook();
+    }
+
+    if (saved_plugin_directory) {
+        FalconExecuteInlinePlugins(saved_plugin_directory);
+    }
+}
+
+/*
+ * Unified plugin system initialization
+ * Called from _PG_init() - handles both BACKGROUND and INLINE plugins
+ */
+int FalconPluginSystemInit(const char *plugin_dir)
+{
+    if (!plugin_dir) {
+        ereport(LOG, (errmsg("Plugin directory not specified")));
+        return -1;
+    }
+
+    /* Save plugin directory for later INLINE execution */
+    saved_plugin_directory = pstrdup(plugin_dir);
+
+    prev_plugin_shmem_startup_hook = shmem_startup_hook;
+    shmem_startup_hook = FalconPluginShmemStartupHook;
+
+    /* Register BACKGROUND plugins immediately */
+    return FalconRegisterBackgroundPlugins(plugin_dir);
+}
+
+/*
+ * Register background plugins during _PG_init() phase
+ * Called internally by FalconPluginSystemInit()
+ */
+static int FalconRegisterBackgroundPlugins(const char *plugin_dir)
+{
+    DIR *dir;
+    struct dirent *entry;
+    char plugin_path[512];
+
+    if (!plugin_dir) {
+        ereport(LOG, (errmsg("Background plugin directory not specified")));
+        return -1;
+    }
+
+    dir = opendir(plugin_dir);
+    if (!dir) {
+        ereport(LOG, (errmsg("Cannot open plugin directory: %s", plugin_dir)));
+        return -1;
+    }
+
+    ereport(LOG, (errmsg("Registering background plugins from directory: %s", plugin_dir)));
+
+    while ((entry = readdir(dir)) != NULL) {
+        void *dl_handle;
+        falcon_plugin_init_func_t init_func;
+        falcon_plugin_get_type_func_t get_type_func;
+        falcon_plugin_work_func_t work_func;
+        falcon_plugin_cleanup_func_t cleanup_func;
+        FalconPluginWorkType work_type;
+
+        /* Skip non-.so files */
+        if (strstr(entry->d_name, ".so") == NULL) {
+            continue;
+        }
+
+        snprintf(plugin_path, sizeof(plugin_path), "%s/%s", plugin_dir, entry->d_name);
+
+        dl_handle = FalconPluginLoadAndValidate(plugin_path, entry->d_name,
+                                                &init_func, &get_type_func,
+                                                &work_func, &cleanup_func);
+        if (!dl_handle) {
+            continue;
+        }
+
+        work_type = get_type_func();
+
+        /* Only register BACKGROUND plugins in this phase */
+        if (work_type == FALCON_PLUGIN_TYPE_BACKGROUND) {
+            BackgroundWorker worker;
+
+            ereport(LOG, (errmsg("Plugin %s type: BACKGROUND (registering worker)", entry->d_name)));
+
+            /* 保存插件信息，延迟到 FalconPluginShmemInit 后再调用 init_func */
+            if (saved_background_plugin_count >= FALCON_PLUGIN_MAX_PLUGINS) {
+                ereport(WARNING, (errmsg("Too many background plugins, cannot save %s", entry->d_name)));
+                dlclose(dl_handle);
+                continue;
+            }
+
+            SavedBackgroundPluginInfo *saved = &saved_background_plugins[saved_background_plugin_count];
+            strncpy(saved->plugin_path, plugin_path, FALCON_PLUGIN_MAX_PATH_SIZE - 1);
+            strncpy(saved->plugin_name, entry->d_name, FALCON_PLUGIN_MAX_NAME_SIZE - 1);
+            saved->init_func = init_func;
+            saved->dl_handle = dl_handle;  /* 保持打开，不 dlclose */
+            saved_background_plugin_count++;
+
+            ereport(LOG, (errmsg("Saved background plugin %s for later initialization (count=%d)",
+                                entry->d_name, saved_background_plugin_count)));
+
+            /* 注册后台工作进程 */
+            memset(&worker, 0, sizeof(BackgroundWorker));
+            snprintf(worker.bgw_name, BGW_MAXLEN, "falcon_plugin_%s", entry->d_name);
+            snprintf(worker.bgw_type, BGW_MAXLEN, "falcon_plugin_worker");
+            worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
+            worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
+            worker.bgw_restart_time = BGW_NEVER_RESTART;
+            snprintf(worker.bgw_library_name, BGW_MAXLEN, "falcon");
+            snprintf(worker.bgw_function_name, BGW_MAXLEN, "FalconPluginBackgroundWorkerMain");
+
+            /* Store plugin path in bgw_extra field */
+            snprintf(worker.bgw_extra, BGW_EXTRALEN, "%s", plugin_path);
+
+            RegisterBackgroundWorker(&worker);
+            ereport(LOG, (errmsg("Registered background worker for plugin: %s", entry->d_name)));
+        }
+        else {
+            /* INLINE 插件立即关闭 */
+            dlclose(dl_handle);
+        }
+    }
+
+    closedir(dir);
+    return 0;
+}
+
+/*
+ * Execute inline plugins after shared memory initialization
+ * Called internally by FalconPluginShmemStartupHook()
+ */
+static int FalconExecuteInlinePlugins(const char *plugin_dir)
+{
+    DIR *dir;
+    struct dirent *entry;
+    char plugin_path[512];
+
+    if (!plugin_dir) {
+        ereport(LOG, (errmsg("Inline plugin directory not specified")));
+        return -1;
+    }
+
+    dir = opendir(plugin_dir);
+    if (!dir) {
+        ereport(LOG, (errmsg("Cannot open plugin directory: %s", plugin_dir)));
+        return -1;
+    }
+
+    if (!falcon_plugin_shmem_initialized) {
+        ereport(ERROR, (errmsg("Plugin shared memory not initialized before executing inline plugins")));
+        closedir(dir);
+        return -1;
+    }
+
+    ereport(LOG, (errmsg("Executing inline plugins from directory: %s, Main PID: %d",
+                        plugin_dir, getpid())));
+
+    while ((entry = readdir(dir)) != NULL) {
+        void *dl_handle;
+        falcon_plugin_init_func_t init_func;
+        falcon_plugin_get_type_func_t get_type_func;
+        falcon_plugin_work_func_t work_func;
+        falcon_plugin_cleanup_func_t cleanup_func;
+        FalconPluginWorkType work_type;
+        int slot_index;
+        int ret;
+
+        /* Skip non-.so files */
+        if (strstr(entry->d_name, ".so") == NULL) {
+            continue;
+        }
+
+        snprintf(plugin_path, sizeof(plugin_path), "%s/%s", plugin_dir, entry->d_name);
+
+        dl_handle = FalconPluginLoadAndValidate(plugin_path, entry->d_name,
+                                                &init_func, &get_type_func,
+                                                &work_func, &cleanup_func);
+        if (!dl_handle) {
+            continue;
+        }
+
+        work_type = get_type_func();
+
+        /* Only execute INLINE plugins in this phase */
+        if (work_type == FALCON_PLUGIN_TYPE_INLINE) {
+            ereport(LOG, (errmsg("Plugin %s type: INLINE", entry->d_name)));
+
+            slot_index = FalconPluginGetFreeSlot();
+            if (slot_index < 0) {
+                ereport(WARNING, (errmsg("Cannot allocate shared memory slot for plugin %s", entry->d_name)));
+                dlclose(dl_handle);
+                continue;
+            }
+
+            FalconPluginInitializeSlot(slot_index, entry->d_name, plugin_path);
+            ereport(LOG, (errmsg("Allocated shared memory slot %d for plugin %s", slot_index, entry->d_name)));
+
+            ret = FalconPluginExecuteInline(slot_index, entry->d_name, init_func, work_func, cleanup_func);
+            if (ret == 0) {
+                ereport(LOG, (errmsg("Plugin %s INLINE execution completed", entry->d_name)));
+            }
+
+            FalconPluginReleaseSlot(slot_index);
+        }
+
+        dlclose(dl_handle);
+    }
+
+    closedir(dir);
+    return 0;
+}
+
+void FalconPluginBackgroundWorkerMain(Datum main_arg)
+{
+    void *dl_handle = NULL;
+    falcon_plugin_work_func_t work_func;
+    falcon_plugin_cleanup_func_t cleanup_func;
+    FalconPluginData *plugin_data = NULL;
+    char plugin_path[512];
+    char *plugin_name;
+    int slot_index;
+    int ret;
+    bool falconHasBeenLoad = false;
+
+    BackgroundWorkerUnblockSignals();
+
+    BackgroundWorkerInitializeConnection("postgres", NULL, 0);
+
+    CurrentResourceOwner = ResourceOwnerCreate(NULL, "falcon plugin");
+    CurrentMemoryContext = AllocSetContextCreate(TopMemoryContext,
+                                                 "falcon plugin context",
+                                                 ALLOCSET_DEFAULT_MINSIZE,
+                                                 ALLOCSET_DEFAULT_INITSIZE,
+                                                 ALLOCSET_DEFAULT_MAXSIZE);
+
+    ereport(LOG, (errmsg("FalconPluginBackgroundWorkerMain: waiting for falcon extension...")));
+    while (true) {
+        StartTransactionCommand();
+        falconHasBeenLoad = CheckFalconHasBeenLoaded();
+        CommitTransactionCommand();
+        if (falconHasBeenLoad) {
+            break;
+        }
+        sleep(1);
+    }
+
+    ereport(LOG, (errmsg("FalconPluginBackgroundWorkerMain: checking recovery status...")));
+    while (RecoveryInProgress()) {
+        sleep(1);
+    }
+
+    ereport(LOG, (errmsg("FalconPluginBackgroundWorkerMain: database ready")));
+
+    if (!falcon_plugin_shmem_initialized) {
+        FalconPluginShmemInit();
+    }
+
+    /* Get plugin path from bgw_extra */
+    strncpy(plugin_path, MyBgworkerEntry->bgw_extra, BGW_EXTRALEN - 1);
+    plugin_path[BGW_EXTRALEN - 1] = '\0';
+
+    /* Extract plugin name from path */
+    plugin_name = strrchr(plugin_path, '/');
+    if (plugin_name) {
+        plugin_name++;  /* Skip the '/' */
+    } else {
+        plugin_name = plugin_path;
+    }
+
+    ereport(LOG, (errmsg("Background worker started for plugin: %s", plugin_name)));
+
+    /* Find the slot index by matching plugin_path in shared memory */
+    slot_index = -1;
+    for (int i = 0; i < falcon_plugin_shmem->num_slots; i++) {
+        if (falcon_plugin_shmem->plugins[i].in_use &&
+            strcmp(falcon_plugin_shmem->plugins[i].plugin_path, plugin_path) == 0) {
+            slot_index = i;
+            break;
+        }
+    }
+
+    if (slot_index < 0) {
+        ereport(ERROR, (errmsg("Cannot find shared memory slot for plugin: %s (path: %s)",
+                              plugin_name, plugin_path)));
+        proc_exit(1);
+    }
+
+    ereport(LOG, (errmsg("Found slot %d for plugin: %s", slot_index, plugin_name)));
+
+    /* Get plugin data from shared memory slot */
+    if (slot_index < 0 || slot_index >= falcon_plugin_shmem->num_slots) {
+        ereport(ERROR, (errmsg("Invalid slot index %d for plugin %s", slot_index, plugin_name)));
+        proc_exit(1);
+    }
+
+    plugin_data = &falcon_plugin_shmem->plugins[slot_index];
+    if (!plugin_data->in_use) {
+        ereport(ERROR, (errmsg("Slot %d not in use for plugin %s", slot_index, plugin_name)));
+        proc_exit(1);
+    }
+
+    /* Load plugin */
+    dl_handle = dlopen(plugin_path, RTLD_LAZY);
+    if (!dl_handle) {
+        ereport(ERROR, (errmsg("Failed to load plugin in background worker: %s, error: %s",
+                              plugin_path, dlerror())));
+        proc_exit(1);
+    }
+
+    work_func = (falcon_plugin_work_func_t)dlsym(dl_handle, FALCON_PLUGIN_WORK_FUNC_NAME);
+    cleanup_func = (falcon_plugin_cleanup_func_t)dlsym(dl_handle, FALCON_PLUGIN_CLEANUP_FUNC_NAME);
+
+    if (!work_func || !cleanup_func) {
+        ereport(ERROR, (errmsg("Plugin %s missing required functions (work/cleanup)", plugin_name)));
+        dlclose(dl_handle);
+        proc_exit(1);
+    }
+
+    /* Execute plugin work */
+    ret = work_func(plugin_data);
+    ereport(LOG, (errmsg("Plugin work function returned %d: %s", ret, plugin_name)));
+    
+    do {
+        sleep(1);
+    } while (true);
+
+    /* Cleanup */
+    ereport(LOG, (errmsg("Background worker stopping: %s", plugin_name)));
+    cleanup_func(plugin_data);
+
+    dlclose(dl_handle);
+
+    proc_exit(0);
+}
diff --git a/falcon/utils/utils.c b/falcon/utils/utils.c
index f3686eb..ca64a1f 100644
--- a/falcon/utils/utils.c
+++ b/falcon/utils/utils.c
@@ -67,7 +67,6 @@ Oid CachedRelationOid[LAST_CACHED_RELATION_TYPE] = {0};
 
 void GetRelationOid(const char *relationName, Oid *relOid)
 {
-    InitializeInvalidationCallbacks();
     if (*relOid == InvalidOid) {
         *relOid = get_relname_relid(relationName, PG_CATALOG_NAMESPACE);
 
@@ -94,6 +93,9 @@ static void InitializeDirectoryTableScanCache(void);
 static void InitializeInodeTableScanCache(void);
 static void InitializeInodeTableIndexParentIdPartIdNameScanCache(void);
 static void InitializeXattrTableScanCache(void);
+static void InitializeSliceTableScanCache(void);
+static void InitializeKvmetaTableScanCache(void);
+static void InitializeSliceIdTableScanCache(void);
 
 static MemoryContext ScanCacheMemoryContext = NULL;
 
@@ -249,6 +251,48 @@ static void InitializeXattrTableScanCache(void)
     XattrTableScanKey[XATTR_TABLE_XKEY_EQ].sk_attno = Anum_falcon_xattr_table_xkey;
 }
 
+ScanKeyData SliceTableScanKey[LAST_FALCON_SLICE_TABLE_SCANKEY_TYPE];
+static void InitializeSliceTableScanCache(void)
+{
+    memset(SliceTableScanKey, 0, sizeof(SliceTableScanKey));
+
+    fmgr_info_cxt(F_INT8EQ, &SliceTableScanKey[SLICE_TABLE_INODEID_EQ].sk_func, ScanCacheMemoryContext);
+    SliceTableScanKey[SLICE_TABLE_INODEID_EQ].sk_strategy = BTEqualStrategyNumber;
+    SliceTableScanKey[SLICE_TABLE_INODEID_EQ].sk_subtype = INT8OID;
+    SliceTableScanKey[SLICE_TABLE_INODEID_EQ].sk_collation = DEFAULT_COLLATION_OID;
+    SliceTableScanKey[SLICE_TABLE_INODEID_EQ].sk_attno = Anum_falcon_slice_table_inodeid;
+
+    fmgr_info_cxt(F_INT4EQ, &SliceTableScanKey[SLICE_TABLE_CHUNKID_EQ].sk_func, ScanCacheMemoryContext);
+    SliceTableScanKey[SLICE_TABLE_CHUNKID_EQ].sk_strategy = BTEqualStrategyNumber;
+    SliceTableScanKey[SLICE_TABLE_CHUNKID_EQ].sk_subtype = INT4OID;
+    SliceTableScanKey[SLICE_TABLE_CHUNKID_EQ].sk_collation = DEFAULT_COLLATION_OID;
+    SliceTableScanKey[SLICE_TABLE_CHUNKID_EQ].sk_attno = Anum_falcon_slice_table_chunkid;
+}
+
+ScanKeyData KvmetaTableScanKey[LAST_FALCON_KVMETA_TABLE_SCANKEY_TYPE];
+static void InitializeKvmetaTableScanCache(void)
+{
+    memset(KvmetaTableScanKey, 0, sizeof(KvmetaTableScanKey));
+
+    fmgr_info_cxt(F_TEXTEQ, &KvmetaTableScanKey[KVMETA_TABLE_USERKEY_EQ].sk_func, ScanCacheMemoryContext);
+    KvmetaTableScanKey[KVMETA_TABLE_USERKEY_EQ].sk_strategy = BTEqualStrategyNumber;
+    KvmetaTableScanKey[KVMETA_TABLE_USERKEY_EQ].sk_subtype = TEXTOID;
+    KvmetaTableScanKey[KVMETA_TABLE_USERKEY_EQ].sk_collation = DEFAULT_COLLATION_OID;
+    KvmetaTableScanKey[KVMETA_TABLE_USERKEY_EQ].sk_attno = Anum_falcon_kvmeta_table_userkey;
+}
+
+ScanKeyData SliceIdTableScanKey[LAST_FALCON_SLICEID_TABLE_SCANKEY_TYPE];
+static void InitializeSliceIdTableScanCache(void)
+{
+    memset(SliceIdTableScanKey, 0, sizeof(SliceIdTableScanKey));
+
+    fmgr_info_cxt(F_TEXTEQ, &SliceIdTableScanKey[SLICEID_TABLE_SLICEID_EQ].sk_func, ScanCacheMemoryContext);
+    SliceIdTableScanKey[SLICEID_TABLE_SLICEID_EQ].sk_strategy = BTEqualStrategyNumber;
+    SliceIdTableScanKey[SLICEID_TABLE_SLICEID_EQ].sk_subtype = TEXTOID;
+    SliceIdTableScanKey[SLICEID_TABLE_SLICEID_EQ].sk_collation = DEFAULT_COLLATION_OID;
+    SliceIdTableScanKey[SLICEID_TABLE_SLICEID_EQ].sk_attno = Anum_falcon_sliceid_table_keystr;
+}
+
 /*
  * InitializeInvalidationCallbacks() registers invalidation handlers
  */
@@ -280,6 +324,9 @@ void SetUpScanCaches(void)
             InitializeInodeTableScanCache();
             InitializeInodeTableIndexParentIdPartIdNameScanCache();
             InitializeXattrTableScanCache();
+            InitializeSliceTableScanCache();
+            InitializeKvmetaTableScanCache();
+            InitializeSliceIdTableScanCache();
         }
         PG_CATCH();
         {
diff --git a/remote_connection_def/fbs/falcon_meta_param.fbs b/remote_connection_def/fbs/falcon_meta_param.fbs
index 1831bc6..f0aeb1a 100644
--- a/remote_connection_def/fbs/falcon_meta_param.fbs
+++ b/remote_connection_def/fbs/falcon_meta_param.fbs
@@ -87,6 +87,38 @@ table ChmodParam {
     path: string;
     st_mode: uint64;
 }
+table KeyOnlyParam {
+    key: string;
+}
+table KVParam {
+    key: string;
+    value_len: uint32;
+    slice_num: uint16;
+    value_key: [uint64];
+    location: [uint64];
+    size: [uint32];
+}
+table SliceInfoParam {
+    filename: string;
+    slicenum: uint32;
+    inodeid: [uint64];
+    chunkid: [uint32];
+    sliceid: [uint64];
+    slicesize: [uint32];
+    sliceoffset: [uint32];
+    slicelen: [uint32];
+    sliceloc1: [uint32];
+    sliceloc2: [uint32];
+}
+table SliceIndexParam {
+    filename: string;
+    inodeid: uint64;
+    chunkid: uint32;
+}
+table SliceIdParam {
+    count: uint32;
+    type: uint8;
+}
 union AnyMetaParam {
     PlainCommandParam,
     PathOnlyParam,
@@ -101,7 +133,12 @@ union AnyMetaParam {
     RenameSubCreateParam,
     UtimeNsParam,
     ChownParam,
-    ChmodParam
+    ChmodParam,
+    KVParam,
+    KeyOnlyParam,
+    SliceInfoParam,
+    SliceIndexParam,
+    SliceIdParam
 }
 table MetaParam {
     param: AnyMetaParam;
diff --git a/remote_connection_def/fbs/falcon_meta_response.fbs b/remote_connection_def/fbs/falcon_meta_response.fbs
index ab42528..69d49c3 100644
--- a/remote_connection_def/fbs/falcon_meta_response.fbs
+++ b/remote_connection_def/fbs/falcon_meta_response.fbs
@@ -85,6 +85,28 @@ table RenameSubRenameLocallyResponse {
     st_ctim: uint64;
     node_id: int32;
 }
+table GetKVMetaResponse {
+    value_len: uint32;
+    slice_num: uint16;
+    value_key: [uint64];
+    location: [uint64];
+    size: [uint32];
+}
+table SliceInfoResponse {
+    slicenum: uint32;
+    inodeid: [uint64];
+    chunkid: [uint32];
+    sliceid: [uint64];
+    slicesize: [uint32];
+    sliceoffset: [uint32];
+    slicelen: [uint32];
+    sliceloc1: [uint32];
+    sliceloc2: [uint32];
+}
+table SliceIdResponse {
+    startid: uint64;
+    endid: uint64;
+}
 union AnyMetaResponse {
     PlainCommandResponse,
     CreateResponse,
@@ -93,7 +115,10 @@ union AnyMetaResponse {
     UnlinkResponse,
     ReadDirResponse,
     OpenDirResponse,
-    RenameSubRenameLocallyResponse
+    RenameSubRenameLocallyResponse,
+    GetKVMetaResponse,
+    SliceInfoResponse,
+    SliceIdResponse
 }
 table MetaResponse {
     error_code: uint32;
diff --git a/remote_connection_def/proto/falcon_meta_rpc.proto b/remote_connection_def/proto/falcon_meta_rpc.proto
index 45952ff..f30c2b7 100644
--- a/remote_connection_def/proto/falcon_meta_rpc.proto
+++ b/remote_connection_def/proto/falcon_meta_rpc.proto
@@ -25,6 +25,13 @@ enum MetaServiceType {
     UTIMENS = 17;
     CHOWN = 18;
     CHMOD = 19;
+    KV_PUT = 20;
+    KV_GET = 21;
+    KV_DEL = 22;
+    SLICE_PUT = 23;
+    SLICE_GET = 24;
+    SLICE_DEL = 25;
+    FETCH_SLICE_ID = 26;
 }
 
 message MetaRequest {
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index d6b9232..8f16f59 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -1,3 +1,4 @@
 add_subdirectory(falcon_store)
 add_subdirectory(private-directory-test)
-add_subdirectory(common)
\ No newline at end of file
+add_subdirectory(common)
+add_subdirectory(falcon_plugin)
diff --git a/tests/falcon_plugin/CMakeLists.txt b/tests/falcon_plugin/CMakeLists.txt
new file mode 100644
index 0000000..a77dd2e
--- /dev/null
+++ b/tests/falcon_plugin/CMakeLists.txt
@@ -0,0 +1,49 @@
+include(GoogleTest)
+
+enable_testing()
+
+# Create test plugins directory
+file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/test_plugins)
+
+# Include plugin framework headers
+include_directories(
+    ${PROJECT_SOURCE_DIR}/falcon/include
+)
+
+# Test plugins
+add_library(test_plugin_inline SHARED test_plugin_inline.c)
+set_target_properties(test_plugin_inline PROPERTIES
+    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/test_plugins
+)
+
+add_library(test_plugin_background SHARED test_plugin_background.c)
+set_target_properties(test_plugin_background PROPERTIES
+    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/test_plugins
+)
+
+add_library(test_plugin_invalid SHARED test_plugin_invalid.c)
+set_target_properties(test_plugin_invalid PROPERTIES
+    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/test_plugins
+)
+
+# ==================== PluginFrameworkUT =================
+add_executable(PluginFrameworkUT
+    ${PROJECT_SOURCE_DIR}/tests/falcon_plugin/test_plugin_framework.cpp
+)
+target_link_libraries(PluginFrameworkUT
+    gtest
+    dl
+)
+
+gtest_discover_tests(PluginFrameworkUT)
+
+# ==================== PluginLoaderUT =================
+add_executable(PluginLoaderUT
+    ${PROJECT_SOURCE_DIR}/tests/falcon_plugin/test_plugin_loader.cpp
+)
+target_link_libraries(PluginLoaderUT
+    gtest
+    dl
+)
+
+gtest_discover_tests(PluginLoaderUT)
\ No newline at end of file
diff --git a/tests/falcon_plugin/test_plugin_background.c b/tests/falcon_plugin/test_plugin_background.c
new file mode 100644
index 0000000..80c83f2
--- /dev/null
+++ b/tests/falcon_plugin/test_plugin_background.c
@@ -0,0 +1,58 @@
+// Test plugin - BACKGROUND type
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include "plugin/falcon_plugin_framework.h"
+
+/* Plugin private data structure */
+typedef struct {
+    int counter;
+    pid_t worker_pid;
+} BackgroundPluginPrivateData;
+
+int plugin_init(FalconPluginData *data)
+{
+    printf("[TEST PLUGIN BACKGROUND] plugin_init() called\n");
+    if (data) {
+        BackgroundPluginPrivateData *private_data = (BackgroundPluginPrivateData *)data->plugin_data.raw_buffer;
+        private_data->counter = 0;
+        private_data->worker_pid = getpid();
+        printf("[TEST PLUGIN BACKGROUND] Init - Worker PID: %d\n", private_data->worker_pid);
+    }
+    return 0;
+}
+
+FalconPluginWorkType plugin_get_type(void)
+{
+    printf("[TEST PLUGIN BACKGROUND] plugin_get_type() called, returning BACKGROUND\n");
+    return FALCON_PLUGIN_TYPE_BACKGROUND;
+}
+
+int plugin_work(FalconPluginData *data)
+{
+    printf("[TEST PLUGIN BACKGROUND] plugin_work() called\n");
+    if (data) {
+        printf("[TEST PLUGIN BACKGROUND] Plugin name: %s\n", data->plugin_name);
+        printf("[TEST PLUGIN BACKGROUND] Shared memory buffer address: %p\n", (void*)data);
+
+        BackgroundPluginPrivateData *private_data = (BackgroundPluginPrivateData *)data->plugin_data.raw_buffer;
+        private_data->counter++;
+        printf("[TEST PLUGIN BACKGROUND] Work - Counter: %d, Worker PID: %d\n",
+               private_data->counter, private_data->worker_pid);
+
+        /* Simulate some background work */
+        usleep(10000);
+    }
+    printf("[TEST PLUGIN BACKGROUND] Background work completed\n");
+    return 0;
+}
+
+void plugin_cleanup(FalconPluginData *data)
+{
+    printf("[TEST PLUGIN BACKGROUND] plugin_cleanup() called\n");
+    if (data) {
+        BackgroundPluginPrivateData *private_data = (BackgroundPluginPrivateData *)data->plugin_data.raw_buffer;
+        printf("[TEST PLUGIN BACKGROUND] Cleanup - Final counter: %d\n", private_data->counter);
+    }
+}
diff --git a/tests/falcon_plugin/test_plugin_framework.cpp b/tests/falcon_plugin/test_plugin_framework.cpp
new file mode 100644
index 0000000..2f747cc
--- /dev/null
+++ b/tests/falcon_plugin/test_plugin_framework.cpp
@@ -0,0 +1,115 @@
+#include "test_plugin_framework.h"
+#include <cstring>
+
+std::string PluginFrameworkUT::inline_plugin_path = "";
+std::string PluginFrameworkUT::background_plugin_path = "";
+std::string PluginFrameworkUT::invalid_plugin_path = "";
+
+/* ------------------------------------------- Plugin Loading Tests -------------------------------------------*/
+
+TEST_F(PluginFrameworkUT, LoadInlinePluginSuccess)
+{
+    void* dl_handle = nullptr;
+    falcon_plugin_get_type_func_t get_type_func = nullptr;
+    falcon_plugin_work_func_t work_func = nullptr;
+
+    bool result = LoadPlugin(inline_plugin_path, dl_handle, get_type_func, work_func);
+    EXPECT_TRUE(result);
+    EXPECT_NE(dl_handle, nullptr);
+    EXPECT_NE(get_type_func, nullptr);
+    EXPECT_NE(work_func, nullptr);
+
+    if (dl_handle) {
+        dlclose(dl_handle);
+    }
+}
+
+TEST_F(PluginFrameworkUT, LoadBackgroundPluginSuccess)
+{
+    void* dl_handle = nullptr;
+    falcon_plugin_get_type_func_t get_type_func = nullptr;
+    falcon_plugin_work_func_t work_func = nullptr;
+
+    bool result = LoadPlugin(background_plugin_path, dl_handle, get_type_func, work_func);
+    EXPECT_TRUE(result);
+    EXPECT_NE(dl_handle, nullptr);
+    EXPECT_NE(get_type_func, nullptr);
+    EXPECT_NE(work_func, nullptr);
+
+    if (dl_handle) {
+        dlclose(dl_handle);
+    }
+}
+
+TEST_F(PluginFrameworkUT, LoadNonExistentPlugin)
+{
+    void* dl_handle = nullptr;
+    falcon_plugin_get_type_func_t get_type_func = nullptr;
+    falcon_plugin_work_func_t work_func = nullptr;
+
+    std::string nonexistent_path = "./test_plugins/libnonexistent.so";
+    bool result = LoadPlugin(nonexistent_path, dl_handle, get_type_func, work_func);
+    EXPECT_FALSE(result);
+    EXPECT_EQ(dl_handle, nullptr);
+}
+
+/* ------------------------------------------- Plugin Function Tests -------------------------------------------*/
+
+TEST_F(PluginFrameworkUT, InlinePluginFunctionCalls)
+{
+    void* dl_handle = nullptr;
+    falcon_plugin_get_type_func_t get_type_func = nullptr;
+    falcon_plugin_work_func_t work_func = nullptr;
+
+    ASSERT_TRUE(LoadPlugin(inline_plugin_path, dl_handle, get_type_func, work_func));
+    ASSERT_NE(get_type_func, nullptr);
+    ASSERT_NE(work_func, nullptr);
+
+    FalconPluginWorkType type = get_type_func();
+    EXPECT_EQ(type, FALCON_PLUGIN_TYPE_INLINE);
+
+    // Create test shared data
+    FalconPluginData test_data;
+    memset(&test_data, 0, sizeof(test_data));
+    strcpy(test_data.plugin_name, "test_inline");
+    strcpy(test_data.plugin_path, inline_plugin_path.c_str());
+    test_data.main_pid = getpid();
+
+    int work_result = work_func(&test_data);
+    EXPECT_EQ(work_result, 0);
+
+    dlclose(dl_handle);
+}
+
+TEST_F(PluginFrameworkUT, BackgroundPluginFunctionCalls)
+{
+    void* dl_handle = nullptr;
+    falcon_plugin_get_type_func_t get_type_func = nullptr;
+    falcon_plugin_work_func_t work_func = nullptr;
+
+    ASSERT_TRUE(LoadPlugin(background_plugin_path, dl_handle, get_type_func, work_func));
+    ASSERT_NE(get_type_func, nullptr);
+    ASSERT_NE(work_func, nullptr);
+
+    FalconPluginWorkType type = get_type_func();
+    EXPECT_EQ(type, FALCON_PLUGIN_TYPE_BACKGROUND);
+
+    // Create test shared data
+    FalconPluginData test_data;
+    memset(&test_data, 0, sizeof(test_data));
+    strcpy(test_data.plugin_name, "test_background");
+    strcpy(test_data.plugin_path, background_plugin_path.c_str());
+    test_data.main_pid = getpid();
+
+    // Test plugin work function
+    int work_result = work_func(&test_data);
+    EXPECT_EQ(work_result, 0);
+
+    dlclose(dl_handle);
+}
+
+int main(int argc, char **argv)
+{
+    testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
\ No newline at end of file
diff --git a/tests/falcon_plugin/test_plugin_framework.h b/tests/falcon_plugin/test_plugin_framework.h
new file mode 100644
index 0000000..ed458cd
--- /dev/null
+++ b/tests/falcon_plugin/test_plugin_framework.h
@@ -0,0 +1,88 @@
+#pragma once
+
+#include <gtest/gtest.h>
+#include <dlfcn.h>
+#include <string>
+#include <vector>
+#include <filesystem>
+
+extern "C" {
+#include "plugin/falcon_plugin_framework.h"
+}
+
+class PluginFrameworkUT : public testing::Test {
+public:
+    static void SetUpTestSuite()
+    {
+        std::cout << "Calling PluginFrameworkUT SetUpTestSuite!" << std::endl;
+
+        // Initialize test plugin paths - try multiple possible locations
+        std::vector<std::string> possible_paths = {
+            "./test_plugins/",  // When run from test directory
+            "build/tests/falcon_plugin/test_plugins/",  // When run from project root
+            "tests/falcon_plugin/test_plugins/"  // Alternative location
+        };
+
+        std::string plugin_dir;
+        for (const auto& path : possible_paths) {
+            if (std::filesystem::exists(path)) {
+                plugin_dir = path;
+                break;
+            }
+        }
+
+        inline_plugin_path = plugin_dir + "libtest_plugin_inline.so";
+        background_plugin_path = plugin_dir + "libtest_plugin_background.so";
+        invalid_plugin_path = plugin_dir + "libtest_plugin_invalid.so";
+    }
+
+    static void TearDownTestSuite()
+    {
+        std::cout << "Calling PluginFrameworkUT TearDownTestSuite!" << std::endl;
+    }
+
+    void SetUp() override {}
+    void TearDown() override {}
+
+    // Helper function to load plugin and get function pointers
+    bool LoadPlugin(const std::string& path, void*& dl_handle,
+                   falcon_plugin_get_type_func_t& get_type_func,
+                   falcon_plugin_work_func_t& work_func)
+    {
+        dl_handle = dlopen(path.c_str(), RTLD_LAZY);
+        if (!dl_handle) {
+            return false;
+        }
+
+        get_type_func = (falcon_plugin_get_type_func_t)dlsym(dl_handle, FALCON_PLUGIN_GET_TYPE_FUNC_NAME);
+        work_func = (falcon_plugin_work_func_t)dlsym(dl_handle, FALCON_PLUGIN_WORK_FUNC_NAME);
+
+        return true;
+    }
+
+    // Helper function to load plugin with init and cleanup functions
+    bool LoadPluginFull(const std::string& path, void*& dl_handle,
+                       falcon_plugin_init_func_t& init_func,
+                       falcon_plugin_get_type_func_t& get_type_func,
+                       falcon_plugin_work_func_t& work_func,
+                       falcon_plugin_cleanup_func_t& cleanup_func)
+    {
+        dl_handle = dlopen(path.c_str(), RTLD_LAZY);
+        if (!dl_handle) {
+            return false;
+        }
+
+        init_func = (falcon_plugin_init_func_t)dlsym(dl_handle, FALCON_PLUGIN_INIT_FUNC_NAME);
+        get_type_func = (falcon_plugin_get_type_func_t)dlsym(dl_handle, FALCON_PLUGIN_GET_TYPE_FUNC_NAME);
+        work_func = (falcon_plugin_work_func_t)dlsym(dl_handle, FALCON_PLUGIN_WORK_FUNC_NAME);
+        cleanup_func = (falcon_plugin_cleanup_func_t)dlsym(dl_handle, FALCON_PLUGIN_CLEANUP_FUNC_NAME);
+
+        return true;
+    }
+
+    static std::string inline_plugin_path;
+    static std::string background_plugin_path;
+    static std::string invalid_plugin_path;
+};
+
+// Static member declarations only
\ No newline at end of file
diff --git a/tests/falcon_plugin/test_plugin_inline.c b/tests/falcon_plugin/test_plugin_inline.c
new file mode 100644
index 0000000..99fd813
--- /dev/null
+++ b/tests/falcon_plugin/test_plugin_inline.c
@@ -0,0 +1,50 @@
+// Test plugin - INLINE type
+
+#include <stdio.h>
+#include <string.h>
+#include "plugin/falcon_plugin_framework.h"
+
+/* Plugin private data structure */
+typedef struct {
+    int counter;
+} InlinePluginPrivateData;
+
+int plugin_init(FalconPluginData *data)
+{
+    printf("[TEST PLUGIN INLINE] plugin_init() called\n");
+    if (data) {
+        InlinePluginPrivateData *private_data = (InlinePluginPrivateData *)data->plugin_data.raw_buffer;
+        private_data->counter = 0;
+        printf("[TEST PLUGIN INLINE] Init - Private data initialized\n");
+    }
+    return 0;
+}
+
+FalconPluginWorkType plugin_get_type(void)
+{
+    printf("[TEST PLUGIN INLINE] plugin_get_type() called, returning INLINE\n");
+    return FALCON_PLUGIN_TYPE_INLINE;
+}
+
+int plugin_work(FalconPluginData *data)
+{
+    printf("[TEST PLUGIN INLINE] plugin_work() called\n");
+    if (data) {
+        printf("[TEST PLUGIN INLINE] Plugin name: %s\n", data->plugin_name);
+        printf("[TEST PLUGIN INLINE] Shared memory buffer address: %p\n", (void*)data);
+
+        InlinePluginPrivateData *private_data = (InlinePluginPrivateData *)data->plugin_data.raw_buffer;
+        private_data->counter++;
+        printf("[TEST PLUGIN INLINE] Work - Counter: %d\n", private_data->counter);
+    }
+    return 0;
+}
+
+void plugin_cleanup(FalconPluginData *data)
+{
+    printf("[TEST PLUGIN INLINE] plugin_cleanup() called\n");
+    if (data) {
+        InlinePluginPrivateData *private_data = (InlinePluginPrivateData *)data->plugin_data.raw_buffer;
+        printf("[TEST PLUGIN INLINE] Cleanup - Final counter: %d\n", private_data->counter);
+    }
+}
diff --git a/tests/falcon_plugin/test_plugin_invalid.c b/tests/falcon_plugin/test_plugin_invalid.c
new file mode 100644
index 0000000..536681e
--- /dev/null
+++ b/tests/falcon_plugin/test_plugin_invalid.c
@@ -0,0 +1,11 @@
+// Invalid test plugin - missing required functions
+
+#include <stdio.h>
+#include <stdlib.h>
+
+// Only has some functions, missing plugin_get_type and plugin_work intentionally
+
+void plugin_dummy_function(void)
+{
+    printf("[TEST PLUGIN INVALID] plugin_dummy_function() called\n");
+}
\ No newline at end of file
diff --git a/tests/falcon_plugin/test_plugin_loader.cpp b/tests/falcon_plugin/test_plugin_loader.cpp
new file mode 100644
index 0000000..cdfe0cf
--- /dev/null
+++ b/tests/falcon_plugin/test_plugin_loader.cpp
@@ -0,0 +1,186 @@
+#include "test_plugin_framework.h"
+#include <cstring>
+#include <filesystem>
+#include <fstream>
+#include <vector>
+
+// Test-specific stub implementation for FalconLoadPluginsFromDirectory
+extern "C" {
+int FalconLoadPluginsFromDirectory(const char* plugin_dir) {
+    if (!plugin_dir) {
+        return -1;
+    }
+
+    // For testing purposes, just check if directory exists
+    if (!std::filesystem::exists(plugin_dir)) {
+        return -1;
+    }
+
+    return 0;
+}
+}
+
+class PluginLoaderUT : public testing::Test {
+public:
+    static void SetUpTestSuite()
+    {
+        std::cout << "Calling PluginLoaderUT SetUpTestSuite!" << std::endl;
+
+        // Initialize test plugin paths - try multiple possible locations
+        std::vector<std::string> possible_paths = {
+            "./test_plugins/",  // When run from test directory
+            "build/tests/falcon_plugin/test_plugins/",  // When run from project root
+            "tests/falcon_plugin/test_plugins/"  // Alternative location
+        };
+
+        std::string plugin_dir;
+        for (const auto& path : possible_paths) {
+            if (std::filesystem::exists(path)) {
+                plugin_dir = path;
+                break;
+            }
+        }
+
+        inline_plugin_path = plugin_dir + "libtest_plugin_inline.so";
+        background_plugin_path = plugin_dir + "libtest_plugin_background.so";
+        invalid_plugin_path = plugin_dir + "libtest_plugin_invalid.so";
+
+        // Create test plugin directory structure
+        test_plugin_dir = "./test_plugin_loader_dir";
+        std::filesystem::create_directories(test_plugin_dir);
+
+        // Copy test plugins to test directory
+        if (std::filesystem::exists(inline_plugin_path)) {
+            std::filesystem::copy_file(inline_plugin_path,
+                                     test_plugin_dir + "/libtest_inline.so",
+                                     std::filesystem::copy_options::overwrite_existing);
+        }
+        if (std::filesystem::exists(background_plugin_path)) {
+            std::filesystem::copy_file(background_plugin_path,
+                                     test_plugin_dir + "/libtest_background.so",
+                                     std::filesystem::copy_options::overwrite_existing);
+        }
+        if (std::filesystem::exists(invalid_plugin_path)) {
+            std::filesystem::copy_file(invalid_plugin_path,
+                                     test_plugin_dir + "/libtest_invalid.so",
+                                     std::filesystem::copy_options::overwrite_existing);
+        }
+
+        // Create non-plugin files to test filtering
+        std::ofstream txt_file(test_plugin_dir + "/readme.txt");
+        txt_file << "This is not a plugin file" << std::endl;
+        txt_file.close();
+
+        std::ofstream other_file(test_plugin_dir + "/libother.a");
+        other_file << "Static library, not a shared library" << std::endl;
+        other_file.close();
+    }
+
+    static void TearDownTestSuite()
+    {
+        std::cout << "Calling PluginLoaderUT TearDownTestSuite!" << std::endl;
+
+        // Clean up test directory
+        if (std::filesystem::exists(test_plugin_dir)) {
+            std::filesystem::remove_all(test_plugin_dir);
+        }
+    }
+
+    void SetUp() override {}
+    void TearDown() override {}
+
+    // Helper function to count loaded plugins by scanning directory
+    int CountPluginFiles(const std::string& directory)
+    {
+        int count = 0;
+        if (!std::filesystem::exists(directory)) {
+            return count;
+        }
+
+        for (const auto& entry : std::filesystem::directory_iterator(directory)) {
+            if (entry.is_regular_file() &&
+                entry.path().extension() == ".so" &&
+                entry.path().filename().string().find("lib") == 0) {
+                count++;
+            }
+        }
+        return count;
+    }
+
+    static std::string inline_plugin_path;
+    static std::string background_plugin_path;
+    static std::string invalid_plugin_path;
+    static std::string test_plugin_dir;
+};
+
+// Static member definitions
+std::string PluginLoaderUT::inline_plugin_path = "";
+std::string PluginLoaderUT::background_plugin_path = "";
+std::string PluginLoaderUT::invalid_plugin_path = "";
+std::string PluginLoaderUT::test_plugin_dir = "";
+
+/* ------------------------------------------- Directory Loading Tests -------------------------------------------*/
+
+TEST_F(PluginLoaderUT, LoadPluginsFromValidDirectory)
+{
+    int plugin_count = CountPluginFiles(test_plugin_dir);
+    EXPECT_GT(plugin_count, 0);
+
+    int result = FalconLoadPluginsFromDirectory(test_plugin_dir.c_str());
+
+    EXPECT_GE(result, 0);
+}
+
+TEST_F(PluginLoaderUT, LoadPluginsFromNonExistentDirectory)
+{
+    std::string nonexistent_dir = "./nonexistent_plugin_directory";
+
+    int result = FalconLoadPluginsFromDirectory(nonexistent_dir.c_str());
+
+    EXPECT_LT(result, 0);
+}
+
+TEST_F(PluginLoaderUT, LoadPluginsWithNullDirectory)
+{
+    int result = FalconLoadPluginsFromDirectory(nullptr);
+
+    EXPECT_LT(result, 0);
+}
+
+/* ------------------------------------------- Integration Tests -------------------------------------------*/
+
+TEST_F(PluginLoaderUT, EndToEndPluginWorkflow)
+{
+    void* dl_handle = dlopen(background_plugin_path.c_str(), RTLD_LAZY);
+    ASSERT_NE(dl_handle, nullptr);
+
+    falcon_plugin_get_type_func_t get_type_func =
+        (falcon_plugin_get_type_func_t)dlsym(dl_handle, FALCON_PLUGIN_GET_TYPE_FUNC_NAME);
+    falcon_plugin_work_func_t work_func =
+        (falcon_plugin_work_func_t)dlsym(dl_handle, FALCON_PLUGIN_WORK_FUNC_NAME);
+
+    ASSERT_NE(get_type_func, nullptr);
+    ASSERT_NE(work_func, nullptr);
+
+    FalconPluginWorkType type = get_type_func();
+    EXPECT_EQ(type, FALCON_PLUGIN_TYPE_BACKGROUND);
+
+    // Create test shared data
+    FalconPluginData test_data;
+    memset(&test_data, 0, sizeof(test_data));
+    strcpy(test_data.plugin_name, "test_background");
+    strcpy(test_data.plugin_path, background_plugin_path.c_str());
+    test_data.main_pid = getpid();
+
+    int work_result = work_func(&test_data);
+    EXPECT_EQ(work_result, 0);
+
+    int close_result = dlclose(dl_handle);
+    EXPECT_EQ(close_result, 0);
+}
+
+int main(int argc, char **argv)
+{
+    testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
\ No newline at end of file
